// Code generated by crd2pulumi DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// Challenge is a type to represent a Challenge request with an ACME server
type ChallengeType struct {
	ApiVersion *string           `pulumi:"apiVersion"`
	Kind       *string           `pulumi:"kind"`
	Metadata   metav1.ObjectMeta `pulumi:"metadata"`
	Spec       ChallengeSpec     `pulumi:"spec"`
	Status     *ChallengeStatus  `pulumi:"status"`
}

type ChallengeMetadata struct {
}

type ChallengeSpec struct {
	// The URL to the ACME Authorization resource that this
	// challenge is a part of.
	AuthorizationURL string `pulumi:"authorizationURL"`
	// dnsName is the identifier that this challenge is for, e.g. example.com.
	// If the requested DNSName is a 'wildcard', this field MUST be set to the
	// non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
	DnsName string `pulumi:"dnsName"`
	// References a properly configured ACME-type Issuer which should
	// be used to create this Challenge.
	// If the Issuer does not exist, processing will be retried.
	// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
	// Challenge will be marked as failed.
	IssuerRef ChallengeSpecIssuerRef `pulumi:"issuerRef"`
	// The ACME challenge key for this challenge
	// For HTTP01 challenges, this is the value that must be responded with to
	// complete the HTTP01 challenge in the format:
	// `<private key JWK thumbprint>.<key from acme server for challenge>`.
	// For DNS01 challenges, this is the base64 encoded SHA256 sum of the
	// `<private key JWK thumbprint>.<key from acme server for challenge>`
	// text that must be set as the TXT record content.
	Key string `pulumi:"key"`
	// Contains the domain solving configuration that should be used to
	// solve this challenge resource.
	Solver ChallengeSpecSolver `pulumi:"solver"`
	// The ACME challenge token for this challenge.
	// This is the raw value returned from the ACME server.
	Token string `pulumi:"token"`
	// The type of ACME challenge this resource represents.
	// One of "HTTP-01" or "DNS-01".
	Type string `pulumi:"type"`
	// The URL of the ACME Challenge resource for this challenge.
	// This can be used to lookup details about the status of this challenge.
	Url string `pulumi:"url"`
	// wildcard will be true if this challenge is for a wildcard identifier,
	// for example '*.example.com'.
	Wildcard *bool `pulumi:"wildcard"`
}

// ChallengeSpecInput is an input type that accepts ChallengeSpecArgs and ChallengeSpecOutput values.
// You can construct a concrete instance of `ChallengeSpecInput` via:
//
//	ChallengeSpecArgs{...}
type ChallengeSpecInput interface {
	pulumi.Input

	ToChallengeSpecOutput() ChallengeSpecOutput
	ToChallengeSpecOutputWithContext(context.Context) ChallengeSpecOutput
}

type ChallengeSpecArgs struct {
	// The URL to the ACME Authorization resource that this
	// challenge is a part of.
	AuthorizationURL pulumi.StringInput `pulumi:"authorizationURL"`
	// dnsName is the identifier that this challenge is for, e.g. example.com.
	// If the requested DNSName is a 'wildcard', this field MUST be set to the
	// non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
	DnsName pulumi.StringInput `pulumi:"dnsName"`
	// References a properly configured ACME-type Issuer which should
	// be used to create this Challenge.
	// If the Issuer does not exist, processing will be retried.
	// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
	// Challenge will be marked as failed.
	IssuerRef ChallengeSpecIssuerRefInput `pulumi:"issuerRef"`
	// The ACME challenge key for this challenge
	// For HTTP01 challenges, this is the value that must be responded with to
	// complete the HTTP01 challenge in the format:
	// `<private key JWK thumbprint>.<key from acme server for challenge>`.
	// For DNS01 challenges, this is the base64 encoded SHA256 sum of the
	// `<private key JWK thumbprint>.<key from acme server for challenge>`
	// text that must be set as the TXT record content.
	Key pulumi.StringInput `pulumi:"key"`
	// Contains the domain solving configuration that should be used to
	// solve this challenge resource.
	Solver ChallengeSpecSolverInput `pulumi:"solver"`
	// The ACME challenge token for this challenge.
	// This is the raw value returned from the ACME server.
	Token pulumi.StringInput `pulumi:"token"`
	// The type of ACME challenge this resource represents.
	// One of "HTTP-01" or "DNS-01".
	Type pulumi.StringInput `pulumi:"type"`
	// The URL of the ACME Challenge resource for this challenge.
	// This can be used to lookup details about the status of this challenge.
	Url pulumi.StringInput `pulumi:"url"`
	// wildcard will be true if this challenge is for a wildcard identifier,
	// for example '*.example.com'.
	Wildcard pulumi.BoolPtrInput `pulumi:"wildcard"`
}

func (ChallengeSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpec)(nil)).Elem()
}

func (i ChallengeSpecArgs) ToChallengeSpecOutput() ChallengeSpecOutput {
	return i.ToChallengeSpecOutputWithContext(context.Background())
}

func (i ChallengeSpecArgs) ToChallengeSpecOutputWithContext(ctx context.Context) ChallengeSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecOutput)
}

func (i ChallengeSpecArgs) ToChallengeSpecPtrOutput() ChallengeSpecPtrOutput {
	return i.ToChallengeSpecPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecArgs) ToChallengeSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecOutput).ToChallengeSpecPtrOutputWithContext(ctx)
}

// ChallengeSpecPtrInput is an input type that accepts ChallengeSpecArgs, ChallengeSpecPtr and ChallengeSpecPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecPtrInput` via:
//
//	        ChallengeSpecArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecPtrInput interface {
	pulumi.Input

	ToChallengeSpecPtrOutput() ChallengeSpecPtrOutput
	ToChallengeSpecPtrOutputWithContext(context.Context) ChallengeSpecPtrOutput
}

type challengeSpecPtrType ChallengeSpecArgs

func ChallengeSpecPtr(v *ChallengeSpecArgs) ChallengeSpecPtrInput {
	return (*challengeSpecPtrType)(v)
}

func (*challengeSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpec)(nil)).Elem()
}

func (i *challengeSpecPtrType) ToChallengeSpecPtrOutput() ChallengeSpecPtrOutput {
	return i.ToChallengeSpecPtrOutputWithContext(context.Background())
}

func (i *challengeSpecPtrType) ToChallengeSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecPtrOutput)
}

type ChallengeSpecOutput struct{ *pulumi.OutputState }

func (ChallengeSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpec)(nil)).Elem()
}

func (o ChallengeSpecOutput) ToChallengeSpecOutput() ChallengeSpecOutput {
	return o
}

func (o ChallengeSpecOutput) ToChallengeSpecOutputWithContext(ctx context.Context) ChallengeSpecOutput {
	return o
}

func (o ChallengeSpecOutput) ToChallengeSpecPtrOutput() ChallengeSpecPtrOutput {
	return o.ToChallengeSpecPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecOutput) ToChallengeSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpec) *ChallengeSpec {
		return &v
	}).(ChallengeSpecPtrOutput)
}

// The URL to the ACME Authorization resource that this
// challenge is a part of.
func (o ChallengeSpecOutput) AuthorizationURL() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpec) string { return v.AuthorizationURL }).(pulumi.StringOutput)
}

// dnsName is the identifier that this challenge is for, e.g. example.com.
// If the requested DNSName is a 'wildcard', this field MUST be set to the
// non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
func (o ChallengeSpecOutput) DnsName() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpec) string { return v.DnsName }).(pulumi.StringOutput)
}

// References a properly configured ACME-type Issuer which should
// be used to create this Challenge.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Challenge will be marked as failed.
func (o ChallengeSpecOutput) IssuerRef() ChallengeSpecIssuerRefOutput {
	return o.ApplyT(func(v ChallengeSpec) ChallengeSpecIssuerRef { return v.IssuerRef }).(ChallengeSpecIssuerRefOutput)
}

// The ACME challenge key for this challenge
// For HTTP01 challenges, this is the value that must be responded with to
// complete the HTTP01 challenge in the format:
// `<private key JWK thumbprint>.<key from acme server for challenge>`.
// For DNS01 challenges, this is the base64 encoded SHA256 sum of the
// `<private key JWK thumbprint>.<key from acme server for challenge>`
// text that must be set as the TXT record content.
func (o ChallengeSpecOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpec) string { return v.Key }).(pulumi.StringOutput)
}

// Contains the domain solving configuration that should be used to
// solve this challenge resource.
func (o ChallengeSpecOutput) Solver() ChallengeSpecSolverOutput {
	return o.ApplyT(func(v ChallengeSpec) ChallengeSpecSolver { return v.Solver }).(ChallengeSpecSolverOutput)
}

// The ACME challenge token for this challenge.
// This is the raw value returned from the ACME server.
func (o ChallengeSpecOutput) Token() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpec) string { return v.Token }).(pulumi.StringOutput)
}

// The type of ACME challenge this resource represents.
// One of "HTTP-01" or "DNS-01".
func (o ChallengeSpecOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpec) string { return v.Type }).(pulumi.StringOutput)
}

// The URL of the ACME Challenge resource for this challenge.
// This can be used to lookup details about the status of this challenge.
func (o ChallengeSpecOutput) Url() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpec) string { return v.Url }).(pulumi.StringOutput)
}

// wildcard will be true if this challenge is for a wildcard identifier,
// for example '*.example.com'.
func (o ChallengeSpecOutput) Wildcard() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ChallengeSpec) *bool { return v.Wildcard }).(pulumi.BoolPtrOutput)
}

type ChallengeSpecPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpec)(nil)).Elem()
}

func (o ChallengeSpecPtrOutput) ToChallengeSpecPtrOutput() ChallengeSpecPtrOutput {
	return o
}

func (o ChallengeSpecPtrOutput) ToChallengeSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecPtrOutput {
	return o
}

func (o ChallengeSpecPtrOutput) Elem() ChallengeSpecOutput {
	return o.ApplyT(func(v *ChallengeSpec) ChallengeSpec {
		if v != nil {
			return *v
		}
		var ret ChallengeSpec
		return ret
	}).(ChallengeSpecOutput)
}

// The URL to the ACME Authorization resource that this
// challenge is a part of.
func (o ChallengeSpecPtrOutput) AuthorizationURL() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return &v.AuthorizationURL
	}).(pulumi.StringPtrOutput)
}

// dnsName is the identifier that this challenge is for, e.g. example.com.
// If the requested DNSName is a 'wildcard', this field MUST be set to the
// non-wildcard domain, e.g. for `*.example.com`, it must be `example.com`.
func (o ChallengeSpecPtrOutput) DnsName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return &v.DnsName
	}).(pulumi.StringPtrOutput)
}

// References a properly configured ACME-type Issuer which should
// be used to create this Challenge.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Challenge will be marked as failed.
func (o ChallengeSpecPtrOutput) IssuerRef() ChallengeSpecIssuerRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *ChallengeSpecIssuerRef {
		if v == nil {
			return nil
		}
		return &v.IssuerRef
	}).(ChallengeSpecIssuerRefPtrOutput)
}

// The ACME challenge key for this challenge
// For HTTP01 challenges, this is the value that must be responded with to
// complete the HTTP01 challenge in the format:
// `<private key JWK thumbprint>.<key from acme server for challenge>`.
// For DNS01 challenges, this is the base64 encoded SHA256 sum of the
// `<private key JWK thumbprint>.<key from acme server for challenge>`
// text that must be set as the TXT record content.
func (o ChallengeSpecPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Key
	}).(pulumi.StringPtrOutput)
}

// Contains the domain solving configuration that should be used to
// solve this challenge resource.
func (o ChallengeSpecPtrOutput) Solver() ChallengeSpecSolverPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *ChallengeSpecSolver {
		if v == nil {
			return nil
		}
		return &v.Solver
	}).(ChallengeSpecSolverPtrOutput)
}

// The ACME challenge token for this challenge.
// This is the raw value returned from the ACME server.
func (o ChallengeSpecPtrOutput) Token() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Token
	}).(pulumi.StringPtrOutput)
}

// The type of ACME challenge this resource represents.
// One of "HTTP-01" or "DNS-01".
func (o ChallengeSpecPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// The URL of the ACME Challenge resource for this challenge.
// This can be used to lookup details about the status of this challenge.
func (o ChallengeSpecPtrOutput) Url() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *string {
		if v == nil {
			return nil
		}
		return &v.Url
	}).(pulumi.StringPtrOutput)
}

// wildcard will be true if this challenge is for a wildcard identifier,
// for example '*.example.com'.
func (o ChallengeSpecPtrOutput) Wildcard() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ChallengeSpec) *bool {
		if v == nil {
			return nil
		}
		return v.Wildcard
	}).(pulumi.BoolPtrOutput)
}

// References a properly configured ACME-type Issuer which should
// be used to create this Challenge.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Challenge will be marked as failed.
type ChallengeSpecIssuerRef struct {
	// Group of the resource being referred to.
	Group *string `pulumi:"group"`
	// Kind of the resource being referred to.
	Kind *string `pulumi:"kind"`
	// Name of the resource being referred to.
	Name string `pulumi:"name"`
}

// ChallengeSpecIssuerRefInput is an input type that accepts ChallengeSpecIssuerRefArgs and ChallengeSpecIssuerRefOutput values.
// You can construct a concrete instance of `ChallengeSpecIssuerRefInput` via:
//
//	ChallengeSpecIssuerRefArgs{...}
type ChallengeSpecIssuerRefInput interface {
	pulumi.Input

	ToChallengeSpecIssuerRefOutput() ChallengeSpecIssuerRefOutput
	ToChallengeSpecIssuerRefOutputWithContext(context.Context) ChallengeSpecIssuerRefOutput
}

// References a properly configured ACME-type Issuer which should
// be used to create this Challenge.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Challenge will be marked as failed.
type ChallengeSpecIssuerRefArgs struct {
	// Group of the resource being referred to.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind of the resource being referred to.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name of the resource being referred to.
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecIssuerRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecIssuerRef)(nil)).Elem()
}

func (i ChallengeSpecIssuerRefArgs) ToChallengeSpecIssuerRefOutput() ChallengeSpecIssuerRefOutput {
	return i.ToChallengeSpecIssuerRefOutputWithContext(context.Background())
}

func (i ChallengeSpecIssuerRefArgs) ToChallengeSpecIssuerRefOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecIssuerRefOutput)
}

func (i ChallengeSpecIssuerRefArgs) ToChallengeSpecIssuerRefPtrOutput() ChallengeSpecIssuerRefPtrOutput {
	return i.ToChallengeSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecIssuerRefArgs) ToChallengeSpecIssuerRefPtrOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecIssuerRefOutput).ToChallengeSpecIssuerRefPtrOutputWithContext(ctx)
}

// ChallengeSpecIssuerRefPtrInput is an input type that accepts ChallengeSpecIssuerRefArgs, ChallengeSpecIssuerRefPtr and ChallengeSpecIssuerRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecIssuerRefPtrInput` via:
//
//	        ChallengeSpecIssuerRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecIssuerRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecIssuerRefPtrOutput() ChallengeSpecIssuerRefPtrOutput
	ToChallengeSpecIssuerRefPtrOutputWithContext(context.Context) ChallengeSpecIssuerRefPtrOutput
}

type challengeSpecIssuerRefPtrType ChallengeSpecIssuerRefArgs

func ChallengeSpecIssuerRefPtr(v *ChallengeSpecIssuerRefArgs) ChallengeSpecIssuerRefPtrInput {
	return (*challengeSpecIssuerRefPtrType)(v)
}

func (*challengeSpecIssuerRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecIssuerRef)(nil)).Elem()
}

func (i *challengeSpecIssuerRefPtrType) ToChallengeSpecIssuerRefPtrOutput() ChallengeSpecIssuerRefPtrOutput {
	return i.ToChallengeSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecIssuerRefPtrType) ToChallengeSpecIssuerRefPtrOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecIssuerRefPtrOutput)
}

// References a properly configured ACME-type Issuer which should
// be used to create this Challenge.
// If the Issuer does not exist, processing will be retried.
// If the Issuer is not an 'ACME' Issuer, an error will be returned and the
// Challenge will be marked as failed.
type ChallengeSpecIssuerRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecIssuerRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecIssuerRef)(nil)).Elem()
}

func (o ChallengeSpecIssuerRefOutput) ToChallengeSpecIssuerRefOutput() ChallengeSpecIssuerRefOutput {
	return o
}

func (o ChallengeSpecIssuerRefOutput) ToChallengeSpecIssuerRefOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefOutput {
	return o
}

func (o ChallengeSpecIssuerRefOutput) ToChallengeSpecIssuerRefPtrOutput() ChallengeSpecIssuerRefPtrOutput {
	return o.ToChallengeSpecIssuerRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecIssuerRefOutput) ToChallengeSpecIssuerRefPtrOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecIssuerRef) *ChallengeSpecIssuerRef {
		return &v
	}).(ChallengeSpecIssuerRefPtrOutput)
}

// Group of the resource being referred to.
func (o ChallengeSpecIssuerRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecIssuerRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind of the resource being referred to.
func (o ChallengeSpecIssuerRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecIssuerRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
func (o ChallengeSpecIssuerRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecIssuerRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecIssuerRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecIssuerRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecIssuerRef)(nil)).Elem()
}

func (o ChallengeSpecIssuerRefPtrOutput) ToChallengeSpecIssuerRefPtrOutput() ChallengeSpecIssuerRefPtrOutput {
	return o
}

func (o ChallengeSpecIssuerRefPtrOutput) ToChallengeSpecIssuerRefPtrOutputWithContext(ctx context.Context) ChallengeSpecIssuerRefPtrOutput {
	return o
}

func (o ChallengeSpecIssuerRefPtrOutput) Elem() ChallengeSpecIssuerRefOutput {
	return o.ApplyT(func(v *ChallengeSpecIssuerRef) ChallengeSpecIssuerRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecIssuerRef
		return ret
	}).(ChallengeSpecIssuerRefOutput)
}

// Group of the resource being referred to.
func (o ChallengeSpecIssuerRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind of the resource being referred to.
func (o ChallengeSpecIssuerRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
func (o ChallengeSpecIssuerRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecIssuerRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Contains the domain solving configuration that should be used to
// solve this challenge resource.
type ChallengeSpecSolver struct {
	// Configures cert-manager to attempt to complete authorizations by
	// performing the DNS01 challenge flow.
	Dns01 *ChallengeSpecSolverDns01 `pulumi:"dns01"`
	// Configures cert-manager to attempt to complete authorizations by
	// performing the HTTP01 challenge flow.
	// It is not possible to obtain certificates for wildcard domain names
	// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
	Http01 *ChallengeSpecSolverHttp01 `pulumi:"http01"`
	// Selector selects a set of DNSNames on the Certificate resource that
	// should be solved using this challenge solver.
	// If not specified, the solver will be treated as the 'default' solver
	// with the lowest priority, i.e. if any other solver has a more specific
	// match, it will be used instead.
	Selector *ChallengeSpecSolverSelector `pulumi:"selector"`
}

// ChallengeSpecSolverInput is an input type that accepts ChallengeSpecSolverArgs and ChallengeSpecSolverOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverInput` via:
//
//	ChallengeSpecSolverArgs{...}
type ChallengeSpecSolverInput interface {
	pulumi.Input

	ToChallengeSpecSolverOutput() ChallengeSpecSolverOutput
	ToChallengeSpecSolverOutputWithContext(context.Context) ChallengeSpecSolverOutput
}

// Contains the domain solving configuration that should be used to
// solve this challenge resource.
type ChallengeSpecSolverArgs struct {
	// Configures cert-manager to attempt to complete authorizations by
	// performing the DNS01 challenge flow.
	Dns01 ChallengeSpecSolverDns01PtrInput `pulumi:"dns01"`
	// Configures cert-manager to attempt to complete authorizations by
	// performing the HTTP01 challenge flow.
	// It is not possible to obtain certificates for wildcard domain names
	// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
	Http01 ChallengeSpecSolverHttp01PtrInput `pulumi:"http01"`
	// Selector selects a set of DNSNames on the Certificate resource that
	// should be solved using this challenge solver.
	// If not specified, the solver will be treated as the 'default' solver
	// with the lowest priority, i.e. if any other solver has a more specific
	// match, it will be used instead.
	Selector ChallengeSpecSolverSelectorPtrInput `pulumi:"selector"`
}

func (ChallengeSpecSolverArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolver)(nil)).Elem()
}

func (i ChallengeSpecSolverArgs) ToChallengeSpecSolverOutput() ChallengeSpecSolverOutput {
	return i.ToChallengeSpecSolverOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverArgs) ToChallengeSpecSolverOutputWithContext(ctx context.Context) ChallengeSpecSolverOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverOutput)
}

func (i ChallengeSpecSolverArgs) ToChallengeSpecSolverPtrOutput() ChallengeSpecSolverPtrOutput {
	return i.ToChallengeSpecSolverPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverArgs) ToChallengeSpecSolverPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverOutput).ToChallengeSpecSolverPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverPtrInput is an input type that accepts ChallengeSpecSolverArgs, ChallengeSpecSolverPtr and ChallengeSpecSolverPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverPtrInput` via:
//
//	        ChallengeSpecSolverArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverPtrOutput() ChallengeSpecSolverPtrOutput
	ToChallengeSpecSolverPtrOutputWithContext(context.Context) ChallengeSpecSolverPtrOutput
}

type challengeSpecSolverPtrType ChallengeSpecSolverArgs

func ChallengeSpecSolverPtr(v *ChallengeSpecSolverArgs) ChallengeSpecSolverPtrInput {
	return (*challengeSpecSolverPtrType)(v)
}

func (*challengeSpecSolverPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolver)(nil)).Elem()
}

func (i *challengeSpecSolverPtrType) ToChallengeSpecSolverPtrOutput() ChallengeSpecSolverPtrOutput {
	return i.ToChallengeSpecSolverPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverPtrType) ToChallengeSpecSolverPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverPtrOutput)
}

// Contains the domain solving configuration that should be used to
// solve this challenge resource.
type ChallengeSpecSolverOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolver)(nil)).Elem()
}

func (o ChallengeSpecSolverOutput) ToChallengeSpecSolverOutput() ChallengeSpecSolverOutput {
	return o
}

func (o ChallengeSpecSolverOutput) ToChallengeSpecSolverOutputWithContext(ctx context.Context) ChallengeSpecSolverOutput {
	return o
}

func (o ChallengeSpecSolverOutput) ToChallengeSpecSolverPtrOutput() ChallengeSpecSolverPtrOutput {
	return o.ToChallengeSpecSolverPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverOutput) ToChallengeSpecSolverPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolver) *ChallengeSpecSolver {
		return &v
	}).(ChallengeSpecSolverPtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the DNS01 challenge flow.
func (o ChallengeSpecSolverOutput) Dns01() ChallengeSpecSolverDns01PtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolver) *ChallengeSpecSolverDns01 { return v.Dns01 }).(ChallengeSpecSolverDns01PtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the HTTP01 challenge flow.
// It is not possible to obtain certificates for wildcard domain names
// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
func (o ChallengeSpecSolverOutput) Http01() ChallengeSpecSolverHttp01PtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolver) *ChallengeSpecSolverHttp01 { return v.Http01 }).(ChallengeSpecSolverHttp01PtrOutput)
}

// Selector selects a set of DNSNames on the Certificate resource that
// should be solved using this challenge solver.
// If not specified, the solver will be treated as the 'default' solver
// with the lowest priority, i.e. if any other solver has a more specific
// match, it will be used instead.
func (o ChallengeSpecSolverOutput) Selector() ChallengeSpecSolverSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolver) *ChallengeSpecSolverSelector { return v.Selector }).(ChallengeSpecSolverSelectorPtrOutput)
}

type ChallengeSpecSolverPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolver)(nil)).Elem()
}

func (o ChallengeSpecSolverPtrOutput) ToChallengeSpecSolverPtrOutput() ChallengeSpecSolverPtrOutput {
	return o
}

func (o ChallengeSpecSolverPtrOutput) ToChallengeSpecSolverPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverPtrOutput {
	return o
}

func (o ChallengeSpecSolverPtrOutput) Elem() ChallengeSpecSolverOutput {
	return o.ApplyT(func(v *ChallengeSpecSolver) ChallengeSpecSolver {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolver
		return ret
	}).(ChallengeSpecSolverOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the DNS01 challenge flow.
func (o ChallengeSpecSolverPtrOutput) Dns01() ChallengeSpecSolverDns01PtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolver) *ChallengeSpecSolverDns01 {
		if v == nil {
			return nil
		}
		return v.Dns01
	}).(ChallengeSpecSolverDns01PtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the HTTP01 challenge flow.
// It is not possible to obtain certificates for wildcard domain names
// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
func (o ChallengeSpecSolverPtrOutput) Http01() ChallengeSpecSolverHttp01PtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolver) *ChallengeSpecSolverHttp01 {
		if v == nil {
			return nil
		}
		return v.Http01
	}).(ChallengeSpecSolverHttp01PtrOutput)
}

// Selector selects a set of DNSNames on the Certificate resource that
// should be solved using this challenge solver.
// If not specified, the solver will be treated as the 'default' solver
// with the lowest priority, i.e. if any other solver has a more specific
// match, it will be used instead.
func (o ChallengeSpecSolverPtrOutput) Selector() ChallengeSpecSolverSelectorPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolver) *ChallengeSpecSolverSelector {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(ChallengeSpecSolverSelectorPtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the DNS01 challenge flow.
type ChallengeSpecSolverDns01 struct {
	// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
	// DNS01 challenge records.
	AcmeDNS *ChallengeSpecSolverDns01AcmeDns `pulumi:"acmeDNS"`
	// Use the Akamai DNS zone management API to manage DNS01 challenge records.
	Akamai *ChallengeSpecSolverDns01Akamai `pulumi:"akamai"`
	// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
	AzureDNS *ChallengeSpecSolverDns01AzureDns `pulumi:"azureDNS"`
	// Use the Google Cloud DNS API to manage DNS01 challenge records.
	CloudDNS *ChallengeSpecSolverDns01CloudDns `pulumi:"cloudDNS"`
	// Use the Cloudflare API to manage DNS01 challenge records.
	Cloudflare *ChallengeSpecSolverDns01Cloudflare `pulumi:"cloudflare"`
	// CNAMEStrategy configures how the DNS01 provider should handle CNAME
	// records when found in DNS zones.
	CnameStrategy *string `pulumi:"cnameStrategy"`
	// Use the DigitalOcean DNS API to manage DNS01 challenge records.
	Digitalocean *ChallengeSpecSolverDns01Digitalocean `pulumi:"digitalocean"`
	// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
	// to manage DNS01 challenge records.
	Rfc2136 *ChallengeSpecSolverDns01Rfc2136 `pulumi:"rfc2136"`
	// Use the AWS Route53 API to manage DNS01 challenge records.
	Route53 *ChallengeSpecSolverDns01Route53 `pulumi:"route53"`
	// Configure an external webhook based DNS01 challenge solver to manage
	// DNS01 challenge records.
	Webhook *ChallengeSpecSolverDns01Webhook `pulumi:"webhook"`
}

// ChallengeSpecSolverDns01Input is an input type that accepts ChallengeSpecSolverDns01Args and ChallengeSpecSolverDns01Output values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Input` via:
//
//	ChallengeSpecSolverDns01Args{...}
type ChallengeSpecSolverDns01Input interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Output() ChallengeSpecSolverDns01Output
	ToChallengeSpecSolverDns01OutputWithContext(context.Context) ChallengeSpecSolverDns01Output
}

// Configures cert-manager to attempt to complete authorizations by
// performing the DNS01 challenge flow.
type ChallengeSpecSolverDns01Args struct {
	// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
	// DNS01 challenge records.
	AcmeDNS ChallengeSpecSolverDns01AcmeDnsPtrInput `pulumi:"acmeDNS"`
	// Use the Akamai DNS zone management API to manage DNS01 challenge records.
	Akamai ChallengeSpecSolverDns01AkamaiPtrInput `pulumi:"akamai"`
	// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
	AzureDNS ChallengeSpecSolverDns01AzureDnsPtrInput `pulumi:"azureDNS"`
	// Use the Google Cloud DNS API to manage DNS01 challenge records.
	CloudDNS ChallengeSpecSolverDns01CloudDnsPtrInput `pulumi:"cloudDNS"`
	// Use the Cloudflare API to manage DNS01 challenge records.
	Cloudflare ChallengeSpecSolverDns01CloudflarePtrInput `pulumi:"cloudflare"`
	// CNAMEStrategy configures how the DNS01 provider should handle CNAME
	// records when found in DNS zones.
	CnameStrategy pulumi.StringPtrInput `pulumi:"cnameStrategy"`
	// Use the DigitalOcean DNS API to manage DNS01 challenge records.
	Digitalocean ChallengeSpecSolverDns01DigitaloceanPtrInput `pulumi:"digitalocean"`
	// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
	// to manage DNS01 challenge records.
	Rfc2136 ChallengeSpecSolverDns01Rfc2136PtrInput `pulumi:"rfc2136"`
	// Use the AWS Route53 API to manage DNS01 challenge records.
	Route53 ChallengeSpecSolverDns01Route53PtrInput `pulumi:"route53"`
	// Configure an external webhook based DNS01 challenge solver to manage
	// DNS01 challenge records.
	Webhook ChallengeSpecSolverDns01WebhookPtrInput `pulumi:"webhook"`
}

func (ChallengeSpecSolverDns01Args) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Args) ToChallengeSpecSolverDns01Output() ChallengeSpecSolverDns01Output {
	return i.ToChallengeSpecSolverDns01OutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Args) ToChallengeSpecSolverDns01OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Output {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Output)
}

func (i ChallengeSpecSolverDns01Args) ToChallengeSpecSolverDns01PtrOutput() ChallengeSpecSolverDns01PtrOutput {
	return i.ToChallengeSpecSolverDns01PtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Args) ToChallengeSpecSolverDns01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Output).ToChallengeSpecSolverDns01PtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01PtrInput is an input type that accepts ChallengeSpecSolverDns01Args, ChallengeSpecSolverDns01Ptr and ChallengeSpecSolverDns01PtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01PtrInput` via:
//
//	        ChallengeSpecSolverDns01Args{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01PtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01PtrOutput() ChallengeSpecSolverDns01PtrOutput
	ToChallengeSpecSolverDns01PtrOutputWithContext(context.Context) ChallengeSpecSolverDns01PtrOutput
}

type challengeSpecSolverDns01PtrType ChallengeSpecSolverDns01Args

func ChallengeSpecSolverDns01Ptr(v *ChallengeSpecSolverDns01Args) ChallengeSpecSolverDns01PtrInput {
	return (*challengeSpecSolverDns01PtrType)(v)
}

func (*challengeSpecSolverDns01PtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01)(nil)).Elem()
}

func (i *challengeSpecSolverDns01PtrType) ToChallengeSpecSolverDns01PtrOutput() ChallengeSpecSolverDns01PtrOutput {
	return i.ToChallengeSpecSolverDns01PtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01PtrType) ToChallengeSpecSolverDns01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01PtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the DNS01 challenge flow.
type ChallengeSpecSolverDns01Output struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Output) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Output) ToChallengeSpecSolverDns01Output() ChallengeSpecSolverDns01Output {
	return o
}

func (o ChallengeSpecSolverDns01Output) ToChallengeSpecSolverDns01OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Output {
	return o
}

func (o ChallengeSpecSolverDns01Output) ToChallengeSpecSolverDns01PtrOutput() ChallengeSpecSolverDns01PtrOutput {
	return o.ToChallengeSpecSolverDns01PtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Output) ToChallengeSpecSolverDns01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01 {
		return &v
	}).(ChallengeSpecSolverDns01PtrOutput)
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
// DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) AcmeDNS() ChallengeSpecSolverDns01AcmeDnsPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01AcmeDns { return v.AcmeDNS }).(ChallengeSpecSolverDns01AcmeDnsPtrOutput)
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) Akamai() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Akamai { return v.Akamai }).(ChallengeSpecSolverDns01AkamaiPtrOutput)
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) AzureDNS() ChallengeSpecSolverDns01AzureDnsPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01AzureDns { return v.AzureDNS }).(ChallengeSpecSolverDns01AzureDnsPtrOutput)
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) CloudDNS() ChallengeSpecSolverDns01CloudDnsPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01CloudDns { return v.CloudDNS }).(ChallengeSpecSolverDns01CloudDnsPtrOutput)
}

// Use the Cloudflare API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) Cloudflare() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Cloudflare { return v.Cloudflare }).(ChallengeSpecSolverDns01CloudflarePtrOutput)
}

// CNAMEStrategy configures how the DNS01 provider should handle CNAME
// records when found in DNS zones.
func (o ChallengeSpecSolverDns01Output) CnameStrategy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *string { return v.CnameStrategy }).(pulumi.StringPtrOutput)
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) Digitalocean() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Digitalocean { return v.Digitalocean }).(ChallengeSpecSolverDns01DigitaloceanPtrOutput)
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
// to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) Rfc2136() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Rfc2136 { return v.Rfc2136 }).(ChallengeSpecSolverDns01Rfc2136PtrOutput)
}

// Use the AWS Route53 API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) Route53() ChallengeSpecSolverDns01Route53PtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Route53 { return v.Route53 }).(ChallengeSpecSolverDns01Route53PtrOutput)
}

// Configure an external webhook based DNS01 challenge solver to manage
// DNS01 challenge records.
func (o ChallengeSpecSolverDns01Output) Webhook() ChallengeSpecSolverDns01WebhookPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Webhook { return v.Webhook }).(ChallengeSpecSolverDns01WebhookPtrOutput)
}

type ChallengeSpecSolverDns01PtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01PtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01PtrOutput) ToChallengeSpecSolverDns01PtrOutput() ChallengeSpecSolverDns01PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01PtrOutput) ToChallengeSpecSolverDns01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01PtrOutput) Elem() ChallengeSpecSolverDns01Output {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) ChallengeSpecSolverDns01 {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01
		return ret
	}).(ChallengeSpecSolverDns01Output)
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
// DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) AcmeDNS() ChallengeSpecSolverDns01AcmeDnsPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01AcmeDns {
		if v == nil {
			return nil
		}
		return v.AcmeDNS
	}).(ChallengeSpecSolverDns01AcmeDnsPtrOutput)
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) Akamai() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Akamai {
		if v == nil {
			return nil
		}
		return v.Akamai
	}).(ChallengeSpecSolverDns01AkamaiPtrOutput)
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) AzureDNS() ChallengeSpecSolverDns01AzureDnsPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01AzureDns {
		if v == nil {
			return nil
		}
		return v.AzureDNS
	}).(ChallengeSpecSolverDns01AzureDnsPtrOutput)
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) CloudDNS() ChallengeSpecSolverDns01CloudDnsPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01CloudDns {
		if v == nil {
			return nil
		}
		return v.CloudDNS
	}).(ChallengeSpecSolverDns01CloudDnsPtrOutput)
}

// Use the Cloudflare API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) Cloudflare() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Cloudflare {
		if v == nil {
			return nil
		}
		return v.Cloudflare
	}).(ChallengeSpecSolverDns01CloudflarePtrOutput)
}

// CNAMEStrategy configures how the DNS01 provider should handle CNAME
// records when found in DNS zones.
func (o ChallengeSpecSolverDns01PtrOutput) CnameStrategy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *string {
		if v == nil {
			return nil
		}
		return v.CnameStrategy
	}).(pulumi.StringPtrOutput)
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) Digitalocean() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Digitalocean {
		if v == nil {
			return nil
		}
		return v.Digitalocean
	}).(ChallengeSpecSolverDns01DigitaloceanPtrOutput)
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
// to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) Rfc2136() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Rfc2136 {
		if v == nil {
			return nil
		}
		return v.Rfc2136
	}).(ChallengeSpecSolverDns01Rfc2136PtrOutput)
}

// Use the AWS Route53 API to manage DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) Route53() ChallengeSpecSolverDns01Route53PtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Route53 {
		if v == nil {
			return nil
		}
		return v.Route53
	}).(ChallengeSpecSolverDns01Route53PtrOutput)
}

// Configure an external webhook based DNS01 challenge solver to manage
// DNS01 challenge records.
func (o ChallengeSpecSolverDns01PtrOutput) Webhook() ChallengeSpecSolverDns01WebhookPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01) *ChallengeSpecSolverDns01Webhook {
		if v == nil {
			return nil
		}
		return v.Webhook
	}).(ChallengeSpecSolverDns01WebhookPtrOutput)
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01AcmeDns struct {
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	AccountSecretRef ChallengeSpecSolverDns01AcmeDnsAccountSecretRef `pulumi:"accountSecretRef"`
	Host             string                                          `pulumi:"host"`
}

// ChallengeSpecSolverDns01AcmeDnsInput is an input type that accepts ChallengeSpecSolverDns01AcmeDnsArgs and ChallengeSpecSolverDns01AcmeDnsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AcmeDnsInput` via:
//
//	ChallengeSpecSolverDns01AcmeDnsArgs{...}
type ChallengeSpecSolverDns01AcmeDnsInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AcmeDnsOutput() ChallengeSpecSolverDns01AcmeDnsOutput
	ToChallengeSpecSolverDns01AcmeDnsOutputWithContext(context.Context) ChallengeSpecSolverDns01AcmeDnsOutput
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01AcmeDnsArgs struct {
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	AccountSecretRef ChallengeSpecSolverDns01AcmeDnsAccountSecretRefInput `pulumi:"accountSecretRef"`
	Host             pulumi.StringInput                                   `pulumi:"host"`
}

func (ChallengeSpecSolverDns01AcmeDnsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDns)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AcmeDnsArgs) ToChallengeSpecSolverDns01AcmeDnsOutput() ChallengeSpecSolverDns01AcmeDnsOutput {
	return i.ToChallengeSpecSolverDns01AcmeDnsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AcmeDnsArgs) ToChallengeSpecSolverDns01AcmeDnsOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDnsOutput)
}

func (i ChallengeSpecSolverDns01AcmeDnsArgs) ToChallengeSpecSolverDns01AcmeDnsPtrOutput() ChallengeSpecSolverDns01AcmeDnsPtrOutput {
	return i.ToChallengeSpecSolverDns01AcmeDnsPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AcmeDnsArgs) ToChallengeSpecSolverDns01AcmeDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDnsOutput).ToChallengeSpecSolverDns01AcmeDnsPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AcmeDnsPtrInput is an input type that accepts ChallengeSpecSolverDns01AcmeDnsArgs, ChallengeSpecSolverDns01AcmeDnsPtr and ChallengeSpecSolverDns01AcmeDnsPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AcmeDnsPtrInput` via:
//
//	        ChallengeSpecSolverDns01AcmeDnsArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AcmeDnsPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AcmeDnsPtrOutput() ChallengeSpecSolverDns01AcmeDnsPtrOutput
	ToChallengeSpecSolverDns01AcmeDnsPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AcmeDnsPtrOutput
}

type challengeSpecSolverDns01AcmeDnsPtrType ChallengeSpecSolverDns01AcmeDnsArgs

func ChallengeSpecSolverDns01AcmeDnsPtr(v *ChallengeSpecSolverDns01AcmeDnsArgs) ChallengeSpecSolverDns01AcmeDnsPtrInput {
	return (*challengeSpecSolverDns01AcmeDnsPtrType)(v)
}

func (*challengeSpecSolverDns01AcmeDnsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AcmeDns)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AcmeDnsPtrType) ToChallengeSpecSolverDns01AcmeDnsPtrOutput() ChallengeSpecSolverDns01AcmeDnsPtrOutput {
	return i.ToChallengeSpecSolverDns01AcmeDnsPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AcmeDnsPtrType) ToChallengeSpecSolverDns01AcmeDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDnsPtrOutput)
}

// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01AcmeDnsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AcmeDnsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDns)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AcmeDnsOutput) ToChallengeSpecSolverDns01AcmeDnsOutput() ChallengeSpecSolverDns01AcmeDnsOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDnsOutput) ToChallengeSpecSolverDns01AcmeDnsOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDnsOutput) ToChallengeSpecSolverDns01AcmeDnsPtrOutput() ChallengeSpecSolverDns01AcmeDnsPtrOutput {
	return o.ToChallengeSpecSolverDns01AcmeDnsPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AcmeDnsOutput) ToChallengeSpecSolverDns01AcmeDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AcmeDns) *ChallengeSpecSolverDns01AcmeDns {
		return &v
	}).(ChallengeSpecSolverDns01AcmeDnsPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AcmeDnsOutput) AccountSecretRef() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDns) ChallengeSpecSolverDns01AcmeDnsAccountSecretRef {
		return v.AccountSecretRef
	}).(ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput)
}

func (o ChallengeSpecSolverDns01AcmeDnsOutput) Host() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDns) string { return v.Host }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AcmeDnsPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AcmeDnsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AcmeDns)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AcmeDnsPtrOutput) ToChallengeSpecSolverDns01AcmeDnsPtrOutput() ChallengeSpecSolverDns01AcmeDnsPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDnsPtrOutput) ToChallengeSpecSolverDns01AcmeDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDnsPtrOutput) Elem() ChallengeSpecSolverDns01AcmeDnsOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDns) ChallengeSpecSolverDns01AcmeDns {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AcmeDns
		return ret
	}).(ChallengeSpecSolverDns01AcmeDnsOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AcmeDnsPtrOutput) AccountSecretRef() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDns) *ChallengeSpecSolverDns01AcmeDnsAccountSecretRef {
		if v == nil {
			return nil
		}
		return &v.AccountSecretRef
	}).(ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput)
}

func (o ChallengeSpecSolverDns01AcmeDnsPtrOutput) Host() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDns) *string {
		if v == nil {
			return nil
		}
		return &v.Host
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AcmeDnsAccountSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AcmeDnsAccountSecretRefInput is an input type that accepts ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs and ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AcmeDnsAccountSecretRefInput` via:
//
//	ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs{...}
type ChallengeSpecSolverDns01AcmeDnsAccountSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput
	ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDnsAccountSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput {
	return i.ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput)
}

func (i ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput).ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs, ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtr and ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput
	ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput
}

type challengeSpecSolverDns01AcmeDnsAccountSecretRefPtrType ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs

func ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtr(v *ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs) ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrInput {
	return (*challengeSpecSolverDns01AcmeDnsAccountSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01AcmeDnsAccountSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AcmeDnsAccountSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AcmeDnsAccountSecretRefPtrType) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AcmeDnsAccountSecretRefPtrType) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDnsAccountSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AcmeDnsAccountSecretRef) *ChallengeSpecSolverDns01AcmeDnsAccountSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDnsAccountSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AcmeDnsAccountSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AcmeDnsAccountSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput) ToChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDnsAccountSecretRef) ChallengeSpecSolverDns01AcmeDnsAccountSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AcmeDnsAccountSecretRef
		return ret
	}).(ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDnsAccountSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AcmeDnsAccountSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Akamai struct {
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	AccessTokenSecretRef ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef `pulumi:"accessTokenSecretRef"`
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	ClientSecretSecretRef ChallengeSpecSolverDns01AkamaiClientSecretSecretRef `pulumi:"clientSecretSecretRef"`
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	ClientTokenSecretRef  ChallengeSpecSolverDns01AkamaiClientTokenSecretRef `pulumi:"clientTokenSecretRef"`
	ServiceConsumerDomain string                                             `pulumi:"serviceConsumerDomain"`
}

// ChallengeSpecSolverDns01AkamaiInput is an input type that accepts ChallengeSpecSolverDns01AkamaiArgs and ChallengeSpecSolverDns01AkamaiOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiInput` via:
//
//	ChallengeSpecSolverDns01AkamaiArgs{...}
type ChallengeSpecSolverDns01AkamaiInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiOutput() ChallengeSpecSolverDns01AkamaiOutput
	ToChallengeSpecSolverDns01AkamaiOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiOutput
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AkamaiArgs struct {
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	AccessTokenSecretRef ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefInput `pulumi:"accessTokenSecretRef"`
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	ClientSecretSecretRef ChallengeSpecSolverDns01AkamaiClientSecretSecretRefInput `pulumi:"clientSecretSecretRef"`
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	ClientTokenSecretRef  ChallengeSpecSolverDns01AkamaiClientTokenSecretRefInput `pulumi:"clientTokenSecretRef"`
	ServiceConsumerDomain pulumi.StringInput                                      `pulumi:"serviceConsumerDomain"`
}

func (ChallengeSpecSolverDns01AkamaiArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Akamai)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AkamaiArgs) ToChallengeSpecSolverDns01AkamaiOutput() ChallengeSpecSolverDns01AkamaiOutput {
	return i.ToChallengeSpecSolverDns01AkamaiOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiArgs) ToChallengeSpecSolverDns01AkamaiOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiOutput)
}

func (i ChallengeSpecSolverDns01AkamaiArgs) ToChallengeSpecSolverDns01AkamaiPtrOutput() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiArgs) ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiOutput).ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AkamaiPtrInput is an input type that accepts ChallengeSpecSolverDns01AkamaiArgs, ChallengeSpecSolverDns01AkamaiPtr and ChallengeSpecSolverDns01AkamaiPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiPtrInput` via:
//
//	        ChallengeSpecSolverDns01AkamaiArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AkamaiPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiPtrOutput() ChallengeSpecSolverDns01AkamaiPtrOutput
	ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiPtrOutput
}

type challengeSpecSolverDns01AkamaiPtrType ChallengeSpecSolverDns01AkamaiArgs

func ChallengeSpecSolverDns01AkamaiPtr(v *ChallengeSpecSolverDns01AkamaiArgs) ChallengeSpecSolverDns01AkamaiPtrInput {
	return (*challengeSpecSolverDns01AkamaiPtrType)(v)
}

func (*challengeSpecSolverDns01AkamaiPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Akamai)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AkamaiPtrType) ToChallengeSpecSolverDns01AkamaiPtrOutput() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AkamaiPtrType) ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiPtrOutput)
}

// Use the Akamai DNS zone management API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AkamaiOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Akamai)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ToChallengeSpecSolverDns01AkamaiOutput() ChallengeSpecSolverDns01AkamaiOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ToChallengeSpecSolverDns01AkamaiOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ToChallengeSpecSolverDns01AkamaiPtrOutput() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o.ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Akamai) *ChallengeSpecSolverDns01Akamai {
		return &v
	}).(ChallengeSpecSolverDns01AkamaiPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AkamaiOutput) AccessTokenSecretRef() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Akamai) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef {
		return v.AccessTokenSecretRef
	}).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AkamaiOutput) ClientSecretSecretRef() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Akamai) ChallengeSpecSolverDns01AkamaiClientSecretSecretRef {
		return v.ClientSecretSecretRef
	}).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AkamaiOutput) ClientTokenSecretRef() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Akamai) ChallengeSpecSolverDns01AkamaiClientTokenSecretRef {
		return v.ClientTokenSecretRef
	}).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput)
}

func (o ChallengeSpecSolverDns01AkamaiOutput) ServiceConsumerDomain() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Akamai) string { return v.ServiceConsumerDomain }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AkamaiPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Akamai)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiPtrOutput) ToChallengeSpecSolverDns01AkamaiPtrOutput() ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiPtrOutput) ToChallengeSpecSolverDns01AkamaiPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiPtrOutput) Elem() ChallengeSpecSolverDns01AkamaiOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Akamai) ChallengeSpecSolverDns01Akamai {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Akamai
		return ret
	}).(ChallengeSpecSolverDns01AkamaiOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AkamaiPtrOutput) AccessTokenSecretRef() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Akamai) *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef {
		if v == nil {
			return nil
		}
		return &v.AccessTokenSecretRef
	}).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AkamaiPtrOutput) ClientSecretSecretRef() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Akamai) *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef {
		if v == nil {
			return nil
		}
		return &v.ClientSecretSecretRef
	}).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01AkamaiPtrOutput) ClientTokenSecretRef() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Akamai) *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef {
		if v == nil {
			return nil
		}
		return &v.ClientTokenSecretRef
	}).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput)
}

func (o ChallengeSpecSolverDns01AkamaiPtrOutput) ServiceConsumerDomain() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Akamai) *string {
		if v == nil {
			return nil
		}
		return &v.ServiceConsumerDomain
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefInput is an input type that accepts ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs and ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefInput` via:
//
//	ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs{...}
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput
	ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return i.ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput)
}

func (i ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput).ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs, ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtr and ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput
	ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput
}

type challengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrType ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs

func ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtr(v *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrInput {
	return (*challengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef
		return ret
	}).(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiAccessTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AkamaiClientSecretSecretRefInput is an input type that accepts ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs and ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiClientSecretSecretRefInput` via:
//
//	ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs{...}
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput
	ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientSecretSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput)
}

func (i ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput).ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs, ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtr and ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput
	ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput
}

type challengeSpecSolverDns01AkamaiClientSecretSecretRefPtrType ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs

func ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtr(v *ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrInput {
	return (*challengeSpecSolverDns01AkamaiClientSecretSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01AkamaiClientSecretSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiClientSecretSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AkamaiClientSecretSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AkamaiClientSecretSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiClientSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) ChallengeSpecSolverDns01AkamaiClientSecretSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AkamaiClientSecretSecretRef
		return ret
	}).(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AkamaiClientTokenSecretRefInput is an input type that accepts ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs and ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiClientTokenSecretRefInput` via:
//
//	ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs{...}
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput
	ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientTokenSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput)
}

func (i ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput).ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs, ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtr and ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput
	ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput
}

type challengeSpecSolverDns01AkamaiClientTokenSecretRefPtrType ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs

func ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtr(v *ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrInput {
	return (*challengeSpecSolverDns01AkamaiClientTokenSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01AkamaiClientTokenSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiClientTokenSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AkamaiClientTokenSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AkamaiClientTokenSecretRefPtrType) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AkamaiClientTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) ChallengeSpecSolverDns01AkamaiClientTokenSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AkamaiClientTokenSecretRef
		return ret
	}).(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AkamaiClientTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AzureDns struct {
	// Auth: Azure Service Principal:
	// The ClientID of the Azure Service Principal used to authenticate with Azure DNS.
	// If set, ClientSecret and TenantID must also be set.
	ClientID *string `pulumi:"clientID"`
	// Auth: Azure Service Principal:
	// A reference to a Secret containing the password associated with the Service Principal.
	// If set, ClientID and TenantID must also be set.
	ClientSecretSecretRef *ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef `pulumi:"clientSecretSecretRef"`
	// name of the Azure environment (default AzurePublicCloud)
	Environment *string `pulumi:"environment"`
	// name of the DNS zone that should be used
	HostedZoneName *string `pulumi:"hostedZoneName"`
	// Auth: Azure Workload Identity or Azure Managed Service Identity:
	// Settings to enable Azure Workload Identity or Azure Managed Service Identity
	// If set, ClientID, ClientSecret and TenantID must not be set.
	ManagedIdentity *ChallengeSpecSolverDns01AzureDnsManagedIdentity `pulumi:"managedIdentity"`
	// resource group the DNS zone is located in
	ResourceGroupName string `pulumi:"resourceGroupName"`
	// ID of the Azure subscription
	SubscriptionID string `pulumi:"subscriptionID"`
	// Auth: Azure Service Principal:
	// The TenantID of the Azure Service Principal used to authenticate with Azure DNS.
	// If set, ClientID and ClientSecret must also be set.
	TenantID *string `pulumi:"tenantID"`
}

// ChallengeSpecSolverDns01AzureDnsInput is an input type that accepts ChallengeSpecSolverDns01AzureDnsArgs and ChallengeSpecSolverDns01AzureDnsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDnsInput` via:
//
//	ChallengeSpecSolverDns01AzureDnsArgs{...}
type ChallengeSpecSolverDns01AzureDnsInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDnsOutput() ChallengeSpecSolverDns01AzureDnsOutput
	ToChallengeSpecSolverDns01AzureDnsOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDnsOutput
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AzureDnsArgs struct {
	// Auth: Azure Service Principal:
	// The ClientID of the Azure Service Principal used to authenticate with Azure DNS.
	// If set, ClientSecret and TenantID must also be set.
	ClientID pulumi.StringPtrInput `pulumi:"clientID"`
	// Auth: Azure Service Principal:
	// A reference to a Secret containing the password associated with the Service Principal.
	// If set, ClientID and TenantID must also be set.
	ClientSecretSecretRef ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrInput `pulumi:"clientSecretSecretRef"`
	// name of the Azure environment (default AzurePublicCloud)
	Environment pulumi.StringPtrInput `pulumi:"environment"`
	// name of the DNS zone that should be used
	HostedZoneName pulumi.StringPtrInput `pulumi:"hostedZoneName"`
	// Auth: Azure Workload Identity or Azure Managed Service Identity:
	// Settings to enable Azure Workload Identity or Azure Managed Service Identity
	// If set, ClientID, ClientSecret and TenantID must not be set.
	ManagedIdentity ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrInput `pulumi:"managedIdentity"`
	// resource group the DNS zone is located in
	ResourceGroupName pulumi.StringInput `pulumi:"resourceGroupName"`
	// ID of the Azure subscription
	SubscriptionID pulumi.StringInput `pulumi:"subscriptionID"`
	// Auth: Azure Service Principal:
	// The TenantID of the Azure Service Principal used to authenticate with Azure DNS.
	// If set, ClientID and ClientSecret must also be set.
	TenantID pulumi.StringPtrInput `pulumi:"tenantID"`
}

func (ChallengeSpecSolverDns01AzureDnsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDns)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AzureDnsArgs) ToChallengeSpecSolverDns01AzureDnsOutput() ChallengeSpecSolverDns01AzureDnsOutput {
	return i.ToChallengeSpecSolverDns01AzureDnsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDnsArgs) ToChallengeSpecSolverDns01AzureDnsOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDnsOutput)
}

func (i ChallengeSpecSolverDns01AzureDnsArgs) ToChallengeSpecSolverDns01AzureDnsPtrOutput() ChallengeSpecSolverDns01AzureDnsPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDnsPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDnsArgs) ToChallengeSpecSolverDns01AzureDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDnsOutput).ToChallengeSpecSolverDns01AzureDnsPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AzureDnsPtrInput is an input type that accepts ChallengeSpecSolverDns01AzureDnsArgs, ChallengeSpecSolverDns01AzureDnsPtr and ChallengeSpecSolverDns01AzureDnsPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDnsPtrInput` via:
//
//	        ChallengeSpecSolverDns01AzureDnsArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AzureDnsPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDnsPtrOutput() ChallengeSpecSolverDns01AzureDnsPtrOutput
	ToChallengeSpecSolverDns01AzureDnsPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDnsPtrOutput
}

type challengeSpecSolverDns01AzureDnsPtrType ChallengeSpecSolverDns01AzureDnsArgs

func ChallengeSpecSolverDns01AzureDnsPtr(v *ChallengeSpecSolverDns01AzureDnsArgs) ChallengeSpecSolverDns01AzureDnsPtrInput {
	return (*challengeSpecSolverDns01AzureDnsPtrType)(v)
}

func (*challengeSpecSolverDns01AzureDnsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDns)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AzureDnsPtrType) ToChallengeSpecSolverDns01AzureDnsPtrOutput() ChallengeSpecSolverDns01AzureDnsPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDnsPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AzureDnsPtrType) ToChallengeSpecSolverDns01AzureDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDnsPtrOutput)
}

// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01AzureDnsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDnsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDns)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDnsOutput) ToChallengeSpecSolverDns01AzureDnsOutput() ChallengeSpecSolverDns01AzureDnsOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsOutput) ToChallengeSpecSolverDns01AzureDnsOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsOutput) ToChallengeSpecSolverDns01AzureDnsPtrOutput() ChallengeSpecSolverDns01AzureDnsPtrOutput {
	return o.ToChallengeSpecSolverDns01AzureDnsPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AzureDnsOutput) ToChallengeSpecSolverDns01AzureDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AzureDns) *ChallengeSpecSolverDns01AzureDns {
		return &v
	}).(ChallengeSpecSolverDns01AzureDnsPtrOutput)
}

// Auth: Azure Service Principal:
// The ClientID of the Azure Service Principal used to authenticate with Azure DNS.
// If set, ClientSecret and TenantID must also be set.
func (o ChallengeSpecSolverDns01AzureDnsOutput) ClientID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDns) *string { return v.ClientID }).(pulumi.StringPtrOutput)
}

// Auth: Azure Service Principal:
// A reference to a Secret containing the password associated with the Service Principal.
// If set, ClientID and TenantID must also be set.
func (o ChallengeSpecSolverDns01AzureDnsOutput) ClientSecretSecretRef() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDns) *ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef {
		return v.ClientSecretSecretRef
	}).(ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput)
}

// name of the Azure environment (default AzurePublicCloud)
func (o ChallengeSpecSolverDns01AzureDnsOutput) Environment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDns) *string { return v.Environment }).(pulumi.StringPtrOutput)
}

// name of the DNS zone that should be used
func (o ChallengeSpecSolverDns01AzureDnsOutput) HostedZoneName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDns) *string { return v.HostedZoneName }).(pulumi.StringPtrOutput)
}

// Auth: Azure Workload Identity or Azure Managed Service Identity:
// Settings to enable Azure Workload Identity or Azure Managed Service Identity
// If set, ClientID, ClientSecret and TenantID must not be set.
func (o ChallengeSpecSolverDns01AzureDnsOutput) ManagedIdentity() ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDns) *ChallengeSpecSolverDns01AzureDnsManagedIdentity {
		return v.ManagedIdentity
	}).(ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput)
}

// resource group the DNS zone is located in
func (o ChallengeSpecSolverDns01AzureDnsOutput) ResourceGroupName() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDns) string { return v.ResourceGroupName }).(pulumi.StringOutput)
}

// ID of the Azure subscription
func (o ChallengeSpecSolverDns01AzureDnsOutput) SubscriptionID() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDns) string { return v.SubscriptionID }).(pulumi.StringOutput)
}

// Auth: Azure Service Principal:
// The TenantID of the Azure Service Principal used to authenticate with Azure DNS.
// If set, ClientID and ClientSecret must also be set.
func (o ChallengeSpecSolverDns01AzureDnsOutput) TenantID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDns) *string { return v.TenantID }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AzureDnsPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDnsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDns)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) ToChallengeSpecSolverDns01AzureDnsPtrOutput() ChallengeSpecSolverDns01AzureDnsPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) ToChallengeSpecSolverDns01AzureDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) Elem() ChallengeSpecSolverDns01AzureDnsOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDns) ChallengeSpecSolverDns01AzureDns {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AzureDns
		return ret
	}).(ChallengeSpecSolverDns01AzureDnsOutput)
}

// Auth: Azure Service Principal:
// The ClientID of the Azure Service Principal used to authenticate with Azure DNS.
// If set, ClientSecret and TenantID must also be set.
func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) ClientID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDns) *string {
		if v == nil {
			return nil
		}
		return v.ClientID
	}).(pulumi.StringPtrOutput)
}

// Auth: Azure Service Principal:
// A reference to a Secret containing the password associated with the Service Principal.
// If set, ClientID and TenantID must also be set.
func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) ClientSecretSecretRef() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDns) *ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef {
		if v == nil {
			return nil
		}
		return v.ClientSecretSecretRef
	}).(ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput)
}

// name of the Azure environment (default AzurePublicCloud)
func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) Environment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDns) *string {
		if v == nil {
			return nil
		}
		return v.Environment
	}).(pulumi.StringPtrOutput)
}

// name of the DNS zone that should be used
func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) HostedZoneName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDns) *string {
		if v == nil {
			return nil
		}
		return v.HostedZoneName
	}).(pulumi.StringPtrOutput)
}

// Auth: Azure Workload Identity or Azure Managed Service Identity:
// Settings to enable Azure Workload Identity or Azure Managed Service Identity
// If set, ClientID, ClientSecret and TenantID must not be set.
func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) ManagedIdentity() ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDns) *ChallengeSpecSolverDns01AzureDnsManagedIdentity {
		if v == nil {
			return nil
		}
		return v.ManagedIdentity
	}).(ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput)
}

// resource group the DNS zone is located in
func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) ResourceGroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDns) *string {
		if v == nil {
			return nil
		}
		return &v.ResourceGroupName
	}).(pulumi.StringPtrOutput)
}

// ID of the Azure subscription
func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) SubscriptionID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDns) *string {
		if v == nil {
			return nil
		}
		return &v.SubscriptionID
	}).(pulumi.StringPtrOutput)
}

// Auth: Azure Service Principal:
// The TenantID of the Azure Service Principal used to authenticate with Azure DNS.
// If set, ClientID and ClientSecret must also be set.
func (o ChallengeSpecSolverDns01AzureDnsPtrOutput) TenantID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDns) *string {
		if v == nil {
			return nil
		}
		return v.TenantID
	}).(pulumi.StringPtrOutput)
}

// Auth: Azure Service Principal:
// A reference to a Secret containing the password associated with the Service Principal.
// If set, ClientID and TenantID must also be set.
type ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefInput is an input type that accepts ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs and ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefInput` via:
//
//	ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs{...}
type ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput
	ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput
}

// Auth: Azure Service Principal:
// A reference to a Secret containing the password associated with the Service Principal.
// If set, ClientID and TenantID must also be set.
type ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput {
	return i.ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput)
}

func (i ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput).ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs, ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtr and ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput
	ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput
}

type challengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrType ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs

func ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtr(v *ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs) ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrInput {
	return (*challengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrType) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrType) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput)
}

// Auth: Azure Service Principal:
// A reference to a Secret containing the password associated with the Service Principal.
// If set, ClientID and TenantID must also be set.
type ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef) *ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef) ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef
		return ret
	}).(ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDnsClientSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Auth: Azure Workload Identity or Azure Managed Service Identity:
// Settings to enable Azure Workload Identity or Azure Managed Service Identity
// If set, ClientID, ClientSecret and TenantID must not be set.
type ChallengeSpecSolverDns01AzureDnsManagedIdentity struct {
	// client ID of the managed identity, can not be used at the same time as resourceID
	ClientID *string `pulumi:"clientID"`
	// resource ID of the managed identity, can not be used at the same time as clientID
	// Cannot be used for Azure Managed Service Identity
	ResourceID *string `pulumi:"resourceID"`
}

// ChallengeSpecSolverDns01AzureDnsManagedIdentityInput is an input type that accepts ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs and ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDnsManagedIdentityInput` via:
//
//	ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs{...}
type ChallengeSpecSolverDns01AzureDnsManagedIdentityInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDnsManagedIdentityOutput() ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput
	ToChallengeSpecSolverDns01AzureDnsManagedIdentityOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput
}

// Auth: Azure Workload Identity or Azure Managed Service Identity:
// Settings to enable Azure Workload Identity or Azure Managed Service Identity
// If set, ClientID, ClientSecret and TenantID must not be set.
type ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs struct {
	// client ID of the managed identity, can not be used at the same time as resourceID
	ClientID pulumi.StringPtrInput `pulumi:"clientID"`
	// resource ID of the managed identity, can not be used at the same time as clientID
	// Cannot be used for Azure Managed Service Identity
	ResourceID pulumi.StringPtrInput `pulumi:"resourceID"`
}

func (ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDnsManagedIdentity)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs) ToChallengeSpecSolverDns01AzureDnsManagedIdentityOutput() ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput {
	return i.ToChallengeSpecSolverDns01AzureDnsManagedIdentityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs) ToChallengeSpecSolverDns01AzureDnsManagedIdentityOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput)
}

func (i ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs) ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput() ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs) ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput).ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrInput is an input type that accepts ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs, ChallengeSpecSolverDns01AzureDnsManagedIdentityPtr and ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrInput` via:
//
//	        ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput() ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput
	ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput
}

type challengeSpecSolverDns01AzureDnsManagedIdentityPtrType ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs

func ChallengeSpecSolverDns01AzureDnsManagedIdentityPtr(v *ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs) ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrInput {
	return (*challengeSpecSolverDns01AzureDnsManagedIdentityPtrType)(v)
}

func (*challengeSpecSolverDns01AzureDnsManagedIdentityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDnsManagedIdentity)(nil)).Elem()
}

func (i *challengeSpecSolverDns01AzureDnsManagedIdentityPtrType) ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput() ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput {
	return i.ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01AzureDnsManagedIdentityPtrType) ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput)
}

// Auth: Azure Workload Identity or Azure Managed Service Identity:
// Settings to enable Azure Workload Identity or Azure Managed Service Identity
// If set, ClientID, ClientSecret and TenantID must not be set.
type ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01AzureDnsManagedIdentity)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput) ToChallengeSpecSolverDns01AzureDnsManagedIdentityOutput() ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput) ToChallengeSpecSolverDns01AzureDnsManagedIdentityOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput) ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput() ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput {
	return o.ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput) ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01AzureDnsManagedIdentity) *ChallengeSpecSolverDns01AzureDnsManagedIdentity {
		return &v
	}).(ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput)
}

// client ID of the managed identity, can not be used at the same time as resourceID
func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput) ClientID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDnsManagedIdentity) *string { return v.ClientID }).(pulumi.StringPtrOutput)
}

// resource ID of the managed identity, can not be used at the same time as clientID
// Cannot be used for Azure Managed Service Identity
func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput) ResourceID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01AzureDnsManagedIdentity) *string { return v.ResourceID }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01AzureDnsManagedIdentity)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput) ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput() ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput) ToChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput) Elem() ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDnsManagedIdentity) ChallengeSpecSolverDns01AzureDnsManagedIdentity {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01AzureDnsManagedIdentity
		return ret
	}).(ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput)
}

// client ID of the managed identity, can not be used at the same time as resourceID
func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput) ClientID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDnsManagedIdentity) *string {
		if v == nil {
			return nil
		}
		return v.ClientID
	}).(pulumi.StringPtrOutput)
}

// resource ID of the managed identity, can not be used at the same time as clientID
// Cannot be used for Azure Managed Service Identity
func (o ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput) ResourceID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01AzureDnsManagedIdentity) *string {
		if v == nil {
			return nil
		}
		return v.ResourceID
	}).(pulumi.StringPtrOutput)
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudDns struct {
	// HostedZoneName is an optional field that tells cert-manager in which
	// Cloud DNS zone the challenge record has to be created.
	// If left empty cert-manager will automatically choose a zone.
	HostedZoneName *string `pulumi:"hostedZoneName"`
	Project        string  `pulumi:"project"`
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	ServiceAccountSecretRef *ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef `pulumi:"serviceAccountSecretRef"`
}

// ChallengeSpecSolverDns01CloudDnsInput is an input type that accepts ChallengeSpecSolverDns01CloudDnsArgs and ChallengeSpecSolverDns01CloudDnsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudDnsInput` via:
//
//	ChallengeSpecSolverDns01CloudDnsArgs{...}
type ChallengeSpecSolverDns01CloudDnsInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudDnsOutput() ChallengeSpecSolverDns01CloudDnsOutput
	ToChallengeSpecSolverDns01CloudDnsOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudDnsOutput
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudDnsArgs struct {
	// HostedZoneName is an optional field that tells cert-manager in which
	// Cloud DNS zone the challenge record has to be created.
	// If left empty cert-manager will automatically choose a zone.
	HostedZoneName pulumi.StringPtrInput `pulumi:"hostedZoneName"`
	Project        pulumi.StringInput    `pulumi:"project"`
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	ServiceAccountSecretRef ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrInput `pulumi:"serviceAccountSecretRef"`
}

func (ChallengeSpecSolverDns01CloudDnsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudDns)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudDnsArgs) ToChallengeSpecSolverDns01CloudDnsOutput() ChallengeSpecSolverDns01CloudDnsOutput {
	return i.ToChallengeSpecSolverDns01CloudDnsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudDnsArgs) ToChallengeSpecSolverDns01CloudDnsOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDnsOutput)
}

func (i ChallengeSpecSolverDns01CloudDnsArgs) ToChallengeSpecSolverDns01CloudDnsPtrOutput() ChallengeSpecSolverDns01CloudDnsPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudDnsPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudDnsArgs) ToChallengeSpecSolverDns01CloudDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDnsOutput).ToChallengeSpecSolverDns01CloudDnsPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudDnsPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudDnsArgs, ChallengeSpecSolverDns01CloudDnsPtr and ChallengeSpecSolverDns01CloudDnsPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudDnsPtrInput` via:
//
//	        ChallengeSpecSolverDns01CloudDnsArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01CloudDnsPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudDnsPtrOutput() ChallengeSpecSolverDns01CloudDnsPtrOutput
	ToChallengeSpecSolverDns01CloudDnsPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudDnsPtrOutput
}

type challengeSpecSolverDns01CloudDnsPtrType ChallengeSpecSolverDns01CloudDnsArgs

func ChallengeSpecSolverDns01CloudDnsPtr(v *ChallengeSpecSolverDns01CloudDnsArgs) ChallengeSpecSolverDns01CloudDnsPtrInput {
	return (*challengeSpecSolverDns01CloudDnsPtrType)(v)
}

func (*challengeSpecSolverDns01CloudDnsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudDns)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudDnsPtrType) ToChallengeSpecSolverDns01CloudDnsPtrOutput() ChallengeSpecSolverDns01CloudDnsPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudDnsPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudDnsPtrType) ToChallengeSpecSolverDns01CloudDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDnsPtrOutput)
}

// Use the Google Cloud DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudDnsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudDnsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudDns)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudDnsOutput) ToChallengeSpecSolverDns01CloudDnsOutput() ChallengeSpecSolverDns01CloudDnsOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDnsOutput) ToChallengeSpecSolverDns01CloudDnsOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDnsOutput) ToChallengeSpecSolverDns01CloudDnsPtrOutput() ChallengeSpecSolverDns01CloudDnsPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudDnsPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudDnsOutput) ToChallengeSpecSolverDns01CloudDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01CloudDns) *ChallengeSpecSolverDns01CloudDns {
		return &v
	}).(ChallengeSpecSolverDns01CloudDnsPtrOutput)
}

// HostedZoneName is an optional field that tells cert-manager in which
// Cloud DNS zone the challenge record has to be created.
// If left empty cert-manager will automatically choose a zone.
func (o ChallengeSpecSolverDns01CloudDnsOutput) HostedZoneName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDns) *string { return v.HostedZoneName }).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01CloudDnsOutput) Project() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDns) string { return v.Project }).(pulumi.StringOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01CloudDnsOutput) ServiceAccountSecretRef() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDns) *ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef {
		return v.ServiceAccountSecretRef
	}).(ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput)
}

type ChallengeSpecSolverDns01CloudDnsPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudDnsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudDns)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudDnsPtrOutput) ToChallengeSpecSolverDns01CloudDnsPtrOutput() ChallengeSpecSolverDns01CloudDnsPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDnsPtrOutput) ToChallengeSpecSolverDns01CloudDnsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDnsPtrOutput) Elem() ChallengeSpecSolverDns01CloudDnsOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDns) ChallengeSpecSolverDns01CloudDns {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01CloudDns
		return ret
	}).(ChallengeSpecSolverDns01CloudDnsOutput)
}

// HostedZoneName is an optional field that tells cert-manager in which
// Cloud DNS zone the challenge record has to be created.
// If left empty cert-manager will automatically choose a zone.
func (o ChallengeSpecSolverDns01CloudDnsPtrOutput) HostedZoneName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDns) *string {
		if v == nil {
			return nil
		}
		return v.HostedZoneName
	}).(pulumi.StringPtrOutput)
}

func (o ChallengeSpecSolverDns01CloudDnsPtrOutput) Project() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDns) *string {
		if v == nil {
			return nil
		}
		return &v.Project
	}).(pulumi.StringPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01CloudDnsPtrOutput) ServiceAccountSecretRef() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDns) *ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef {
		if v == nil {
			return nil
		}
		return v.ServiceAccountSecretRef
	}).(ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefInput is an input type that accepts ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs and ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefInput` via:
//
//	ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs{...}
type ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput
	ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput {
	return i.ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput)
}

func (i ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput).ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs, ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtr and ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput
	ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput
}

type challengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrType ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs

func ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtr(v *ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs) ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrInput {
	return (*challengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrType) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrType) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef) *ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput) ToChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef) ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef
		return ret
	}).(ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the Cloudflare API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Cloudflare struct {
	// API key to use to authenticate with Cloudflare.
	// Note: using an API token to authenticate is now the recommended method
	// as it allows greater control of permissions.
	ApiKeySecretRef *ChallengeSpecSolverDns01CloudflareApiKeySecretRef `pulumi:"apiKeySecretRef"`
	// API token used to authenticate with Cloudflare.
	ApiTokenSecretRef *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef `pulumi:"apiTokenSecretRef"`
	// Email of the account, only required when using API key based authentication.
	Email *string `pulumi:"email"`
}

// ChallengeSpecSolverDns01CloudflareInput is an input type that accepts ChallengeSpecSolverDns01CloudflareArgs and ChallengeSpecSolverDns01CloudflareOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareInput` via:
//
//	ChallengeSpecSolverDns01CloudflareArgs{...}
type ChallengeSpecSolverDns01CloudflareInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareOutput() ChallengeSpecSolverDns01CloudflareOutput
	ToChallengeSpecSolverDns01CloudflareOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareOutput
}

// Use the Cloudflare API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudflareArgs struct {
	// API key to use to authenticate with Cloudflare.
	// Note: using an API token to authenticate is now the recommended method
	// as it allows greater control of permissions.
	ApiKeySecretRef ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput `pulumi:"apiKeySecretRef"`
	// API token used to authenticate with Cloudflare.
	ApiTokenSecretRef ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput `pulumi:"apiTokenSecretRef"`
	// Email of the account, only required when using API key based authentication.
	Email pulumi.StringPtrInput `pulumi:"email"`
}

func (ChallengeSpecSolverDns01CloudflareArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Cloudflare)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudflareArgs) ToChallengeSpecSolverDns01CloudflareOutput() ChallengeSpecSolverDns01CloudflareOutput {
	return i.ToChallengeSpecSolverDns01CloudflareOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareArgs) ToChallengeSpecSolverDns01CloudflareOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareOutput)
}

func (i ChallengeSpecSolverDns01CloudflareArgs) ToChallengeSpecSolverDns01CloudflarePtrOutput() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareArgs) ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareOutput).ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudflarePtrInput is an input type that accepts ChallengeSpecSolverDns01CloudflareArgs, ChallengeSpecSolverDns01CloudflarePtr and ChallengeSpecSolverDns01CloudflarePtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflarePtrInput` via:
//
//	        ChallengeSpecSolverDns01CloudflareArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01CloudflarePtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflarePtrOutput() ChallengeSpecSolverDns01CloudflarePtrOutput
	ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflarePtrOutput
}

type challengeSpecSolverDns01CloudflarePtrType ChallengeSpecSolverDns01CloudflareArgs

func ChallengeSpecSolverDns01CloudflarePtr(v *ChallengeSpecSolverDns01CloudflareArgs) ChallengeSpecSolverDns01CloudflarePtrInput {
	return (*challengeSpecSolverDns01CloudflarePtrType)(v)
}

func (*challengeSpecSolverDns01CloudflarePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Cloudflare)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudflarePtrType) ToChallengeSpecSolverDns01CloudflarePtrOutput() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudflarePtrType) ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflarePtrOutput)
}

// Use the Cloudflare API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01CloudflareOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Cloudflare)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareOutput) ToChallengeSpecSolverDns01CloudflareOutput() ChallengeSpecSolverDns01CloudflareOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareOutput) ToChallengeSpecSolverDns01CloudflareOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareOutput) ToChallengeSpecSolverDns01CloudflarePtrOutput() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o.ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudflareOutput) ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Cloudflare) *ChallengeSpecSolverDns01Cloudflare {
		return &v
	}).(ChallengeSpecSolverDns01CloudflarePtrOutput)
}

// API key to use to authenticate with Cloudflare.
// Note: using an API token to authenticate is now the recommended method
// as it allows greater control of permissions.
func (o ChallengeSpecSolverDns01CloudflareOutput) ApiKeySecretRef() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Cloudflare) *ChallengeSpecSolverDns01CloudflareApiKeySecretRef {
		return v.ApiKeySecretRef
	}).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput)
}

// API token used to authenticate with Cloudflare.
func (o ChallengeSpecSolverDns01CloudflareOutput) ApiTokenSecretRef() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Cloudflare) *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef {
		return v.ApiTokenSecretRef
	}).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput)
}

// Email of the account, only required when using API key based authentication.
func (o ChallengeSpecSolverDns01CloudflareOutput) Email() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Cloudflare) *string { return v.Email }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverDns01CloudflarePtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflarePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Cloudflare)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflarePtrOutput) ToChallengeSpecSolverDns01CloudflarePtrOutput() ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflarePtrOutput) ToChallengeSpecSolverDns01CloudflarePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflarePtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflarePtrOutput) Elem() ChallengeSpecSolverDns01CloudflareOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Cloudflare) ChallengeSpecSolverDns01Cloudflare {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Cloudflare
		return ret
	}).(ChallengeSpecSolverDns01CloudflareOutput)
}

// API key to use to authenticate with Cloudflare.
// Note: using an API token to authenticate is now the recommended method
// as it allows greater control of permissions.
func (o ChallengeSpecSolverDns01CloudflarePtrOutput) ApiKeySecretRef() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Cloudflare) *ChallengeSpecSolverDns01CloudflareApiKeySecretRef {
		if v == nil {
			return nil
		}
		return v.ApiKeySecretRef
	}).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput)
}

// API token used to authenticate with Cloudflare.
func (o ChallengeSpecSolverDns01CloudflarePtrOutput) ApiTokenSecretRef() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Cloudflare) *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef {
		if v == nil {
			return nil
		}
		return v.ApiTokenSecretRef
	}).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput)
}

// Email of the account, only required when using API key based authentication.
func (o ChallengeSpecSolverDns01CloudflarePtrOutput) Email() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Cloudflare) *string {
		if v == nil {
			return nil
		}
		return v.Email
	}).(pulumi.StringPtrOutput)
}

// API key to use to authenticate with Cloudflare.
// Note: using an API token to authenticate is now the recommended method
// as it allows greater control of permissions.
type ChallengeSpecSolverDns01CloudflareApiKeySecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01CloudflareApiKeySecretRefInput is an input type that accepts ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs and ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareApiKeySecretRefInput` via:
//
//	ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs{...}
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput
	ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput
}

// API key to use to authenticate with Cloudflare.
// Note: using an API token to authenticate is now the recommended method
// as it allows greater control of permissions.
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiKeySecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput)
}

func (i ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput).ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs, ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtr and ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput
	ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput
}

type challengeSpecSolverDns01CloudflareApiKeySecretRefPtrType ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs

func ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtr(v *ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput {
	return (*challengeSpecSolverDns01CloudflareApiKeySecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01CloudflareApiKeySecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflareApiKeySecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudflareApiKeySecretRefPtrType) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudflareApiKeySecretRefPtrType) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput)
}

// API key to use to authenticate with Cloudflare.
// Note: using an API token to authenticate is now the recommended method
// as it allows greater control of permissions.
type ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiKeySecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01CloudflareApiKeySecretRef) *ChallengeSpecSolverDns01CloudflareApiKeySecretRef {
		return &v
	}).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiKeySecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiKeySecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflareApiKeySecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) ToChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) Elem() ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiKeySecretRef) ChallengeSpecSolverDns01CloudflareApiKeySecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01CloudflareApiKeySecretRef
		return ret
	}).(ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiKeySecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiKeySecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// API token used to authenticate with Cloudflare.
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01CloudflareApiTokenSecretRefInput is an input type that accepts ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs and ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareApiTokenSecretRefInput` via:
//
//	ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs{...}
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput
	ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput
}

// API token used to authenticate with Cloudflare.
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiTokenSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput)
}

func (i ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput).ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs, ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtr and ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput
	ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput
}

type challengeSpecSolverDns01CloudflareApiTokenSecretRefPtrType ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs

func ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtr(v *ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput {
	return (*challengeSpecSolverDns01CloudflareApiTokenSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01CloudflareApiTokenSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflareApiTokenSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01CloudflareApiTokenSecretRefPtrType) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01CloudflareApiTokenSecretRefPtrType) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput)
}

// API token used to authenticate with Cloudflare.
type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01CloudflareApiTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) ChallengeSpecSolverDns01CloudflareApiTokenSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01CloudflareApiTokenSecretRef
		return ret
	}).(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01CloudflareApiTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Digitalocean struct {
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	TokenSecretRef ChallengeSpecSolverDns01DigitaloceanTokenSecretRef `pulumi:"tokenSecretRef"`
}

// ChallengeSpecSolverDns01DigitaloceanInput is an input type that accepts ChallengeSpecSolverDns01DigitaloceanArgs and ChallengeSpecSolverDns01DigitaloceanOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01DigitaloceanInput` via:
//
//	ChallengeSpecSolverDns01DigitaloceanArgs{...}
type ChallengeSpecSolverDns01DigitaloceanInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01DigitaloceanOutput() ChallengeSpecSolverDns01DigitaloceanOutput
	ToChallengeSpecSolverDns01DigitaloceanOutputWithContext(context.Context) ChallengeSpecSolverDns01DigitaloceanOutput
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01DigitaloceanArgs struct {
	// A reference to a specific 'key' within a Secret resource.
	// In some instances, `key` is a required field.
	TokenSecretRef ChallengeSpecSolverDns01DigitaloceanTokenSecretRefInput `pulumi:"tokenSecretRef"`
}

func (ChallengeSpecSolverDns01DigitaloceanArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Digitalocean)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01DigitaloceanArgs) ToChallengeSpecSolverDns01DigitaloceanOutput() ChallengeSpecSolverDns01DigitaloceanOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01DigitaloceanArgs) ToChallengeSpecSolverDns01DigitaloceanOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanOutput)
}

func (i ChallengeSpecSolverDns01DigitaloceanArgs) ToChallengeSpecSolverDns01DigitaloceanPtrOutput() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01DigitaloceanArgs) ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanOutput).ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01DigitaloceanPtrInput is an input type that accepts ChallengeSpecSolverDns01DigitaloceanArgs, ChallengeSpecSolverDns01DigitaloceanPtr and ChallengeSpecSolverDns01DigitaloceanPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01DigitaloceanPtrInput` via:
//
//	        ChallengeSpecSolverDns01DigitaloceanArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01DigitaloceanPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01DigitaloceanPtrOutput() ChallengeSpecSolverDns01DigitaloceanPtrOutput
	ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01DigitaloceanPtrOutput
}

type challengeSpecSolverDns01DigitaloceanPtrType ChallengeSpecSolverDns01DigitaloceanArgs

func ChallengeSpecSolverDns01DigitaloceanPtr(v *ChallengeSpecSolverDns01DigitaloceanArgs) ChallengeSpecSolverDns01DigitaloceanPtrInput {
	return (*challengeSpecSolverDns01DigitaloceanPtrType)(v)
}

func (*challengeSpecSolverDns01DigitaloceanPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Digitalocean)(nil)).Elem()
}

func (i *challengeSpecSolverDns01DigitaloceanPtrType) ToChallengeSpecSolverDns01DigitaloceanPtrOutput() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01DigitaloceanPtrType) ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanPtrOutput)
}

// Use the DigitalOcean DNS API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01DigitaloceanOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01DigitaloceanOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Digitalocean)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01DigitaloceanOutput) ToChallengeSpecSolverDns01DigitaloceanOutput() ChallengeSpecSolverDns01DigitaloceanOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanOutput) ToChallengeSpecSolverDns01DigitaloceanOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanOutput) ToChallengeSpecSolverDns01DigitaloceanPtrOutput() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o.ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01DigitaloceanOutput) ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Digitalocean) *ChallengeSpecSolverDns01Digitalocean {
		return &v
	}).(ChallengeSpecSolverDns01DigitaloceanPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01DigitaloceanOutput) TokenSecretRef() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Digitalocean) ChallengeSpecSolverDns01DigitaloceanTokenSecretRef {
		return v.TokenSecretRef
	}).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput)
}

type ChallengeSpecSolverDns01DigitaloceanPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01DigitaloceanPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Digitalocean)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01DigitaloceanPtrOutput) ToChallengeSpecSolverDns01DigitaloceanPtrOutput() ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanPtrOutput) ToChallengeSpecSolverDns01DigitaloceanPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanPtrOutput) Elem() ChallengeSpecSolverDns01DigitaloceanOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Digitalocean) ChallengeSpecSolverDns01Digitalocean {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Digitalocean
		return ret
	}).(ChallengeSpecSolverDns01DigitaloceanOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
func (o ChallengeSpecSolverDns01DigitaloceanPtrOutput) TokenSecretRef() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Digitalocean) *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef {
		if v == nil {
			return nil
		}
		return &v.TokenSecretRef
	}).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01DigitaloceanTokenSecretRefInput is an input type that accepts ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs and ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01DigitaloceanTokenSecretRefInput` via:
//
//	ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs{...}
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput
	ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanTokenSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput)
}

func (i ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput).ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs, ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtr and ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput
	ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput
}

type challengeSpecSolverDns01DigitaloceanTokenSecretRefPtrType ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs

func ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtr(v *ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrInput {
	return (*challengeSpecSolverDns01DigitaloceanTokenSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01DigitaloceanTokenSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01DigitaloceanTokenSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01DigitaloceanTokenSecretRefPtrType) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01DigitaloceanTokenSecretRefPtrType) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput)
}

// A reference to a specific 'key' within a Secret resource.
// In some instances, `key` is a required field.
type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01DigitaloceanTokenSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) ToChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) ChallengeSpecSolverDns01DigitaloceanTokenSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01DigitaloceanTokenSecretRef
		return ret
	}).(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01DigitaloceanTokenSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
// to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Rfc2136 struct {
	// The IP address or hostname of an authoritative DNS server supporting
	// RFC2136 in the form host:port. If the host is an IPv6 address it must be
	// enclosed in square brackets (e.g [2001:db8::1]) ; port is optional.
	// This field is required.
	Nameserver string `pulumi:"nameserver"`
	// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
	// when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined.
	// Supported values are (case-insensitive): ``HMACMD5`` (default),
	// ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.
	TsigAlgorithm *string `pulumi:"tsigAlgorithm"`
	// The TSIG Key name configured in the DNS.
	// If ``tsigSecretSecretRef`` is defined, this field is required.
	TsigKeyName *string `pulumi:"tsigKeyName"`
	// The name of the secret containing the TSIG value.
	// If ``tsigKeyName`` is defined, this field is required.
	TsigSecretSecretRef *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef `pulumi:"tsigSecretSecretRef"`
}

// ChallengeSpecSolverDns01Rfc2136Input is an input type that accepts ChallengeSpecSolverDns01Rfc2136Args and ChallengeSpecSolverDns01Rfc2136Output values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Rfc2136Input` via:
//
//	ChallengeSpecSolverDns01Rfc2136Args{...}
type ChallengeSpecSolverDns01Rfc2136Input interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Rfc2136Output() ChallengeSpecSolverDns01Rfc2136Output
	ToChallengeSpecSolverDns01Rfc2136OutputWithContext(context.Context) ChallengeSpecSolverDns01Rfc2136Output
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
// to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Rfc2136Args struct {
	// The IP address or hostname of an authoritative DNS server supporting
	// RFC2136 in the form host:port. If the host is an IPv6 address it must be
	// enclosed in square brackets (e.g [2001:db8::1]) ; port is optional.
	// This field is required.
	Nameserver pulumi.StringInput `pulumi:"nameserver"`
	// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
	// when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined.
	// Supported values are (case-insensitive): ``HMACMD5`` (default),
	// ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.
	TsigAlgorithm pulumi.StringPtrInput `pulumi:"tsigAlgorithm"`
	// The TSIG Key name configured in the DNS.
	// If ``tsigSecretSecretRef`` is defined, this field is required.
	TsigKeyName pulumi.StringPtrInput `pulumi:"tsigKeyName"`
	// The name of the secret containing the TSIG value.
	// If ``tsigKeyName`` is defined, this field is required.
	TsigSecretSecretRef ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput `pulumi:"tsigSecretSecretRef"`
}

func (ChallengeSpecSolverDns01Rfc2136Args) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Rfc2136Args) ToChallengeSpecSolverDns01Rfc2136Output() ChallengeSpecSolverDns01Rfc2136Output {
	return i.ToChallengeSpecSolverDns01Rfc2136OutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Rfc2136Args) ToChallengeSpecSolverDns01Rfc2136OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136Output {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136Output)
}

func (i ChallengeSpecSolverDns01Rfc2136Args) ToChallengeSpecSolverDns01Rfc2136PtrOutput() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Rfc2136Args) ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136Output).ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Rfc2136PtrInput is an input type that accepts ChallengeSpecSolverDns01Rfc2136Args, ChallengeSpecSolverDns01Rfc2136Ptr and ChallengeSpecSolverDns01Rfc2136PtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Rfc2136PtrInput` via:
//
//	        ChallengeSpecSolverDns01Rfc2136Args{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Rfc2136PtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Rfc2136PtrOutput() ChallengeSpecSolverDns01Rfc2136PtrOutput
	ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Rfc2136PtrOutput
}

type challengeSpecSolverDns01Rfc2136PtrType ChallengeSpecSolverDns01Rfc2136Args

func ChallengeSpecSolverDns01Rfc2136Ptr(v *ChallengeSpecSolverDns01Rfc2136Args) ChallengeSpecSolverDns01Rfc2136PtrInput {
	return (*challengeSpecSolverDns01Rfc2136PtrType)(v)
}

func (*challengeSpecSolverDns01Rfc2136PtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Rfc2136)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Rfc2136PtrType) ToChallengeSpecSolverDns01Rfc2136PtrOutput() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Rfc2136PtrType) ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136PtrOutput)
}

// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
// to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Rfc2136Output struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Rfc2136Output) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Rfc2136Output) ToChallengeSpecSolverDns01Rfc2136Output() ChallengeSpecSolverDns01Rfc2136Output {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136Output) ToChallengeSpecSolverDns01Rfc2136OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136Output {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136Output) ToChallengeSpecSolverDns01Rfc2136PtrOutput() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o.ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Rfc2136Output) ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Rfc2136) *ChallengeSpecSolverDns01Rfc2136 {
		return &v
	}).(ChallengeSpecSolverDns01Rfc2136PtrOutput)
}

// The IP address or hostname of an authoritative DNS server supporting
// RFC2136 in the form host:port. If the host is an IPv6 address it must be
// enclosed in square brackets (e.g [2001:db8::1]) ; port is optional.
// This field is required.
func (o ChallengeSpecSolverDns01Rfc2136Output) Nameserver() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136) string { return v.Nameserver }).(pulumi.StringOutput)
}

// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
// when “tsigSecretSecretRef“ and “tsigKeyName“ are defined.
// Supported values are (case-insensitive): “HMACMD5“ (default),
// “HMACSHA1“, “HMACSHA256“ or “HMACSHA512“.
func (o ChallengeSpecSolverDns01Rfc2136Output) TsigAlgorithm() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136) *string { return v.TsigAlgorithm }).(pulumi.StringPtrOutput)
}

// The TSIG Key name configured in the DNS.
// If “tsigSecretSecretRef“ is defined, this field is required.
func (o ChallengeSpecSolverDns01Rfc2136Output) TsigKeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136) *string { return v.TsigKeyName }).(pulumi.StringPtrOutput)
}

// The name of the secret containing the TSIG value.
// If “tsigKeyName“ is defined, this field is required.
func (o ChallengeSpecSolverDns01Rfc2136Output) TsigSecretSecretRef() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136) *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef {
		return v.TsigSecretSecretRef
	}).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput)
}

type ChallengeSpecSolverDns01Rfc2136PtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Rfc2136PtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Rfc2136)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) ToChallengeSpecSolverDns01Rfc2136PtrOutput() ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) ToChallengeSpecSolverDns01Rfc2136PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) Elem() ChallengeSpecSolverDns01Rfc2136Output {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136) ChallengeSpecSolverDns01Rfc2136 {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Rfc2136
		return ret
	}).(ChallengeSpecSolverDns01Rfc2136Output)
}

// The IP address or hostname of an authoritative DNS server supporting
// RFC2136 in the form host:port. If the host is an IPv6 address it must be
// enclosed in square brackets (e.g [2001:db8::1]) ; port is optional.
// This field is required.
func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) Nameserver() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136) *string {
		if v == nil {
			return nil
		}
		return &v.Nameserver
	}).(pulumi.StringPtrOutput)
}

// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
// when “tsigSecretSecretRef“ and “tsigKeyName“ are defined.
// Supported values are (case-insensitive): “HMACMD5“ (default),
// “HMACSHA1“, “HMACSHA256“ or “HMACSHA512“.
func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) TsigAlgorithm() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136) *string {
		if v == nil {
			return nil
		}
		return v.TsigAlgorithm
	}).(pulumi.StringPtrOutput)
}

// The TSIG Key name configured in the DNS.
// If “tsigSecretSecretRef“ is defined, this field is required.
func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) TsigKeyName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136) *string {
		if v == nil {
			return nil
		}
		return v.TsigKeyName
	}).(pulumi.StringPtrOutput)
}

// The name of the secret containing the TSIG value.
// If “tsigKeyName“ is defined, this field is required.
func (o ChallengeSpecSolverDns01Rfc2136PtrOutput) TsigSecretSecretRef() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136) *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef {
		if v == nil {
			return nil
		}
		return v.TsigSecretSecretRef
	}).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput)
}

// The name of the secret containing the TSIG value.
// If “tsigKeyName“ is defined, this field is required.
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefInput is an input type that accepts ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs and ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefInput` via:
//
//	ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs{...}
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput
	ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput
}

// The name of the secret containing the TSIG value.
// If “tsigKeyName“ is defined, this field is required.
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput)
}

func (i ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput).ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs, ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtr and ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput
	ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput
}

type challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrType ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs

func ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtr(v *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput {
	return (*challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrType) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrType) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput)
}

// The name of the secret containing the TSIG value.
// If “tsigKeyName“ is defined, this field is required.
type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef {
		return &v
	}).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) ToChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) Elem() ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef
		return ret
	}).(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Use the AWS Route53 API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Route53 struct {
	// The AccessKeyID is used for authentication.
	// Cannot be set when SecretAccessKeyID is set.
	// If neither the Access Key nor Key ID are set, we fall-back to using env
	// vars, shared credentials file or AWS Instance metadata,
	// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	AccessKeyID *string `pulumi:"accessKeyID"`
	// The SecretAccessKey is used for authentication. If set, pull the AWS
	// access key ID from a key within a Kubernetes Secret.
	// Cannot be set when AccessKeyID is set.
	// If neither the Access Key nor Key ID are set, we fall-back to using env
	// vars, shared credentials file or AWS Instance metadata,
	// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	AccessKeyIDSecretRef *ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef `pulumi:"accessKeyIDSecretRef"`
	// Auth configures how cert-manager authenticates.
	Auth *ChallengeSpecSolverDns01Route53Auth `pulumi:"auth"`
	// If set, the provider will manage only this zone in Route53 and will not do a lookup using the route53:ListHostedZonesByName api call.
	HostedZoneID *string `pulumi:"hostedZoneID"`
	// Override the AWS region.
	//
	// Route53 is a global service and does not have regional endpoints but the
	// region specified here (or via environment variables) is used as a hint to
	// help compute the correct AWS credential scope and partition when it
	// connects to Route53. See:
	// - [Amazon Route 53 endpoints and quotas](https://docs.aws.amazon.com/general/latest/gr/r53.html)
	// - [Global services](https://docs.aws.amazon.com/whitepapers/latest/aws-fault-isolation-boundaries/global-services.html)
	//
	// If you omit this region field, cert-manager will use the region from
	// AWS_REGION and AWS_DEFAULT_REGION environment variables, if they are set
	// in the cert-manager controller Pod.
	//
	// The `region` field is not needed if you use [IAM Roles for Service Accounts (IRSA)](https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html).
	// Instead an AWS_REGION environment variable is added to the cert-manager controller Pod by:
	// [Amazon EKS Pod Identity Webhook](https://github.com/aws/amazon-eks-pod-identity-webhook).
	// In this case this `region` field value is ignored.
	//
	// The `region` field is not needed if you use [EKS Pod Identities](https://docs.aws.amazon.com/eks/latest/userguide/pod-identities.html).
	// Instead an AWS_REGION environment variable is added to the cert-manager controller Pod by:
	// [Amazon EKS Pod Identity Agent](https://github.com/aws/eks-pod-identity-agent),
	// In this case this `region` field value is ignored.
	Region *string `pulumi:"region"`
	// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
	// or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
	Role *string `pulumi:"role"`
	// The SecretAccessKey is used for authentication.
	// If neither the Access Key nor Key ID are set, we fall-back to using env
	// vars, shared credentials file or AWS Instance metadata,
	// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	SecretAccessKeySecretRef *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef `pulumi:"secretAccessKeySecretRef"`
}

// ChallengeSpecSolverDns01Route53Input is an input type that accepts ChallengeSpecSolverDns01Route53Args and ChallengeSpecSolverDns01Route53Output values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53Input` via:
//
//	ChallengeSpecSolverDns01Route53Args{...}
type ChallengeSpecSolverDns01Route53Input interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53Output() ChallengeSpecSolverDns01Route53Output
	ToChallengeSpecSolverDns01Route53OutputWithContext(context.Context) ChallengeSpecSolverDns01Route53Output
}

// Use the AWS Route53 API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Route53Args struct {
	// The AccessKeyID is used for authentication.
	// Cannot be set when SecretAccessKeyID is set.
	// If neither the Access Key nor Key ID are set, we fall-back to using env
	// vars, shared credentials file or AWS Instance metadata,
	// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	AccessKeyID pulumi.StringPtrInput `pulumi:"accessKeyID"`
	// The SecretAccessKey is used for authentication. If set, pull the AWS
	// access key ID from a key within a Kubernetes Secret.
	// Cannot be set when AccessKeyID is set.
	// If neither the Access Key nor Key ID are set, we fall-back to using env
	// vars, shared credentials file or AWS Instance metadata,
	// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	AccessKeyIDSecretRef ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrInput `pulumi:"accessKeyIDSecretRef"`
	// Auth configures how cert-manager authenticates.
	Auth ChallengeSpecSolverDns01Route53AuthPtrInput `pulumi:"auth"`
	// If set, the provider will manage only this zone in Route53 and will not do a lookup using the route53:ListHostedZonesByName api call.
	HostedZoneID pulumi.StringPtrInput `pulumi:"hostedZoneID"`
	// Override the AWS region.
	//
	// Route53 is a global service and does not have regional endpoints but the
	// region specified here (or via environment variables) is used as a hint to
	// help compute the correct AWS credential scope and partition when it
	// connects to Route53. See:
	// - [Amazon Route 53 endpoints and quotas](https://docs.aws.amazon.com/general/latest/gr/r53.html)
	// - [Global services](https://docs.aws.amazon.com/whitepapers/latest/aws-fault-isolation-boundaries/global-services.html)
	//
	// If you omit this region field, cert-manager will use the region from
	// AWS_REGION and AWS_DEFAULT_REGION environment variables, if they are set
	// in the cert-manager controller Pod.
	//
	// The `region` field is not needed if you use [IAM Roles for Service Accounts (IRSA)](https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html).
	// Instead an AWS_REGION environment variable is added to the cert-manager controller Pod by:
	// [Amazon EKS Pod Identity Webhook](https://github.com/aws/amazon-eks-pod-identity-webhook).
	// In this case this `region` field value is ignored.
	//
	// The `region` field is not needed if you use [EKS Pod Identities](https://docs.aws.amazon.com/eks/latest/userguide/pod-identities.html).
	// Instead an AWS_REGION environment variable is added to the cert-manager controller Pod by:
	// [Amazon EKS Pod Identity Agent](https://github.com/aws/eks-pod-identity-agent),
	// In this case this `region` field value is ignored.
	Region pulumi.StringPtrInput `pulumi:"region"`
	// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
	// or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
	Role pulumi.StringPtrInput `pulumi:"role"`
	// The SecretAccessKey is used for authentication.
	// If neither the Access Key nor Key ID are set, we fall-back to using env
	// vars, shared credentials file or AWS Instance metadata,
	// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	SecretAccessKeySecretRef ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput `pulumi:"secretAccessKeySecretRef"`
}

func (ChallengeSpecSolverDns01Route53Args) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53Args) ToChallengeSpecSolverDns01Route53Output() ChallengeSpecSolverDns01Route53Output {
	return i.ToChallengeSpecSolverDns01Route53OutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53Args) ToChallengeSpecSolverDns01Route53OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53Output {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53Output)
}

func (i ChallengeSpecSolverDns01Route53Args) ToChallengeSpecSolverDns01Route53PtrOutput() ChallengeSpecSolverDns01Route53PtrOutput {
	return i.ToChallengeSpecSolverDns01Route53PtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53Args) ToChallengeSpecSolverDns01Route53PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53Output).ToChallengeSpecSolverDns01Route53PtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53PtrInput is an input type that accepts ChallengeSpecSolverDns01Route53Args, ChallengeSpecSolverDns01Route53Ptr and ChallengeSpecSolverDns01Route53PtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53PtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53Args{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53PtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53PtrOutput() ChallengeSpecSolverDns01Route53PtrOutput
	ToChallengeSpecSolverDns01Route53PtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53PtrOutput
}

type challengeSpecSolverDns01Route53PtrType ChallengeSpecSolverDns01Route53Args

func ChallengeSpecSolverDns01Route53Ptr(v *ChallengeSpecSolverDns01Route53Args) ChallengeSpecSolverDns01Route53PtrInput {
	return (*challengeSpecSolverDns01Route53PtrType)(v)
}

func (*challengeSpecSolverDns01Route53PtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53PtrType) ToChallengeSpecSolverDns01Route53PtrOutput() ChallengeSpecSolverDns01Route53PtrOutput {
	return i.ToChallengeSpecSolverDns01Route53PtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53PtrType) ToChallengeSpecSolverDns01Route53PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53PtrOutput)
}

// Use the AWS Route53 API to manage DNS01 challenge records.
type ChallengeSpecSolverDns01Route53Output struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53Output) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53Output) ToChallengeSpecSolverDns01Route53Output() ChallengeSpecSolverDns01Route53Output {
	return o
}

func (o ChallengeSpecSolverDns01Route53Output) ToChallengeSpecSolverDns01Route53OutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53Output {
	return o
}

func (o ChallengeSpecSolverDns01Route53Output) ToChallengeSpecSolverDns01Route53PtrOutput() ChallengeSpecSolverDns01Route53PtrOutput {
	return o.ToChallengeSpecSolverDns01Route53PtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53Output) ToChallengeSpecSolverDns01Route53PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53 {
		return &v
	}).(ChallengeSpecSolverDns01Route53PtrOutput)
}

// The AccessKeyID is used for authentication.
// Cannot be set when SecretAccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
func (o ChallengeSpecSolverDns01Route53Output) AccessKeyID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *string { return v.AccessKeyID }).(pulumi.StringPtrOutput)
}

// The SecretAccessKey is used for authentication. If set, pull the AWS
// access key ID from a key within a Kubernetes Secret.
// Cannot be set when AccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
func (o ChallengeSpecSolverDns01Route53Output) AccessKeyIDSecretRef() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef {
		return v.AccessKeyIDSecretRef
	}).(ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput)
}

// Auth configures how cert-manager authenticates.
func (o ChallengeSpecSolverDns01Route53Output) Auth() ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53Auth { return v.Auth }).(ChallengeSpecSolverDns01Route53AuthPtrOutput)
}

// If set, the provider will manage only this zone in Route53 and will not do a lookup using the route53:ListHostedZonesByName api call.
func (o ChallengeSpecSolverDns01Route53Output) HostedZoneID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *string { return v.HostedZoneID }).(pulumi.StringPtrOutput)
}

// Override the AWS region.
//
// Route53 is a global service and does not have regional endpoints but the
// region specified here (or via environment variables) is used as a hint to
// help compute the correct AWS credential scope and partition when it
// connects to Route53. See:
// - [Amazon Route 53 endpoints and quotas](https://docs.aws.amazon.com/general/latest/gr/r53.html)
// - [Global services](https://docs.aws.amazon.com/whitepapers/latest/aws-fault-isolation-boundaries/global-services.html)
//
// If you omit this region field, cert-manager will use the region from
// AWS_REGION and AWS_DEFAULT_REGION environment variables, if they are set
// in the cert-manager controller Pod.
//
// The `region` field is not needed if you use [IAM Roles for Service Accounts (IRSA)](https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html).
// Instead an AWS_REGION environment variable is added to the cert-manager controller Pod by:
// [Amazon EKS Pod Identity Webhook](https://github.com/aws/amazon-eks-pod-identity-webhook).
// In this case this `region` field value is ignored.
//
// The `region` field is not needed if you use [EKS Pod Identities](https://docs.aws.amazon.com/eks/latest/userguide/pod-identities.html).
// Instead an AWS_REGION environment variable is added to the cert-manager controller Pod by:
// [Amazon EKS Pod Identity Agent](https://github.com/aws/eks-pod-identity-agent),
// In this case this `region` field value is ignored.
func (o ChallengeSpecSolverDns01Route53Output) Region() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *string { return v.Region }).(pulumi.StringPtrOutput)
}

// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
// or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
func (o ChallengeSpecSolverDns01Route53Output) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *string { return v.Role }).(pulumi.StringPtrOutput)
}

// The SecretAccessKey is used for authentication.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
func (o ChallengeSpecSolverDns01Route53Output) SecretAccessKeySecretRef() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef {
		return v.SecretAccessKeySecretRef
	}).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput)
}

type ChallengeSpecSolverDns01Route53PtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53PtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53PtrOutput) ToChallengeSpecSolverDns01Route53PtrOutput() ChallengeSpecSolverDns01Route53PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53PtrOutput) ToChallengeSpecSolverDns01Route53PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53PtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53PtrOutput) Elem() ChallengeSpecSolverDns01Route53Output {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) ChallengeSpecSolverDns01Route53 {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53
		return ret
	}).(ChallengeSpecSolverDns01Route53Output)
}

// The AccessKeyID is used for authentication.
// Cannot be set when SecretAccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
func (o ChallengeSpecSolverDns01Route53PtrOutput) AccessKeyID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *string {
		if v == nil {
			return nil
		}
		return v.AccessKeyID
	}).(pulumi.StringPtrOutput)
}

// The SecretAccessKey is used for authentication. If set, pull the AWS
// access key ID from a key within a Kubernetes Secret.
// Cannot be set when AccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
func (o ChallengeSpecSolverDns01Route53PtrOutput) AccessKeyIDSecretRef() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef {
		if v == nil {
			return nil
		}
		return v.AccessKeyIDSecretRef
	}).(ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput)
}

// Auth configures how cert-manager authenticates.
func (o ChallengeSpecSolverDns01Route53PtrOutput) Auth() ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53Auth {
		if v == nil {
			return nil
		}
		return v.Auth
	}).(ChallengeSpecSolverDns01Route53AuthPtrOutput)
}

// If set, the provider will manage only this zone in Route53 and will not do a lookup using the route53:ListHostedZonesByName api call.
func (o ChallengeSpecSolverDns01Route53PtrOutput) HostedZoneID() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *string {
		if v == nil {
			return nil
		}
		return v.HostedZoneID
	}).(pulumi.StringPtrOutput)
}

// Override the AWS region.
//
// Route53 is a global service and does not have regional endpoints but the
// region specified here (or via environment variables) is used as a hint to
// help compute the correct AWS credential scope and partition when it
// connects to Route53. See:
// - [Amazon Route 53 endpoints and quotas](https://docs.aws.amazon.com/general/latest/gr/r53.html)
// - [Global services](https://docs.aws.amazon.com/whitepapers/latest/aws-fault-isolation-boundaries/global-services.html)
//
// If you omit this region field, cert-manager will use the region from
// AWS_REGION and AWS_DEFAULT_REGION environment variables, if they are set
// in the cert-manager controller Pod.
//
// The `region` field is not needed if you use [IAM Roles for Service Accounts (IRSA)](https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html).
// Instead an AWS_REGION environment variable is added to the cert-manager controller Pod by:
// [Amazon EKS Pod Identity Webhook](https://github.com/aws/amazon-eks-pod-identity-webhook).
// In this case this `region` field value is ignored.
//
// The `region` field is not needed if you use [EKS Pod Identities](https://docs.aws.amazon.com/eks/latest/userguide/pod-identities.html).
// Instead an AWS_REGION environment variable is added to the cert-manager controller Pod by:
// [Amazon EKS Pod Identity Agent](https://github.com/aws/eks-pod-identity-agent),
// In this case this `region` field value is ignored.
func (o ChallengeSpecSolverDns01Route53PtrOutput) Region() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *string {
		if v == nil {
			return nil
		}
		return v.Region
	}).(pulumi.StringPtrOutput)
}

// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
// or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
func (o ChallengeSpecSolverDns01Route53PtrOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *string {
		if v == nil {
			return nil
		}
		return v.Role
	}).(pulumi.StringPtrOutput)
}

// The SecretAccessKey is used for authentication.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
func (o ChallengeSpecSolverDns01Route53PtrOutput) SecretAccessKeySecretRef() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53) *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef {
		if v == nil {
			return nil
		}
		return v.SecretAccessKeySecretRef
	}).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput)
}

// The SecretAccessKey is used for authentication. If set, pull the AWS
// access key ID from a key within a Kubernetes Secret.
// Cannot be set when AccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefInput is an input type that accepts ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs and ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefInput` via:
//
//	ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs{...}
type ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput
	ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput
}

// The SecretAccessKey is used for authentication. If set, pull the AWS
// access key ID from a key within a Kubernetes Secret.
// Cannot be set when AccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput {
	return i.ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput)
}

func (i ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput).ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs, ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtr and ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput
	ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput
}

type challengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrType ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs

func ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtr(v *ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs) ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrInput {
	return (*challengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrType) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrType) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput)
}

// The SecretAccessKey is used for authentication. If set, pull the AWS
// access key ID from a key within a Kubernetes Secret.
// Cannot be set when AccessKeyID is set.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef) *ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef {
		return &v
	}).(ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput) ToChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput) Elem() ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef) ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef
		return ret
	}).(ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AccessKeyIdsecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Auth configures how cert-manager authenticates.
type ChallengeSpecSolverDns01Route53Auth struct {
	// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
	// by passing a bound ServiceAccount token.
	Kubernetes ChallengeSpecSolverDns01Route53AuthKubernetes `pulumi:"kubernetes"`
}

// ChallengeSpecSolverDns01Route53AuthInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthArgs and ChallengeSpecSolverDns01Route53AuthOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthInput` via:
//
//	ChallengeSpecSolverDns01Route53AuthArgs{...}
type ChallengeSpecSolverDns01Route53AuthInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthOutput() ChallengeSpecSolverDns01Route53AuthOutput
	ToChallengeSpecSolverDns01Route53AuthOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthOutput
}

// Auth configures how cert-manager authenticates.
type ChallengeSpecSolverDns01Route53AuthArgs struct {
	// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
	// by passing a bound ServiceAccount token.
	Kubernetes ChallengeSpecSolverDns01Route53AuthKubernetesInput `pulumi:"kubernetes"`
}

func (ChallengeSpecSolverDns01Route53AuthArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53Auth)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53AuthArgs) ToChallengeSpecSolverDns01Route53AuthOutput() ChallengeSpecSolverDns01Route53AuthOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthArgs) ToChallengeSpecSolverDns01Route53AuthOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthOutput)
}

func (i ChallengeSpecSolverDns01Route53AuthArgs) ToChallengeSpecSolverDns01Route53AuthPtrOutput() ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthArgs) ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthOutput).ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53AuthPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthArgs, ChallengeSpecSolverDns01Route53AuthPtr and ChallengeSpecSolverDns01Route53AuthPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53AuthArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53AuthPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthPtrOutput() ChallengeSpecSolverDns01Route53AuthPtrOutput
	ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthPtrOutput
}

type challengeSpecSolverDns01Route53AuthPtrType ChallengeSpecSolverDns01Route53AuthArgs

func ChallengeSpecSolverDns01Route53AuthPtr(v *ChallengeSpecSolverDns01Route53AuthArgs) ChallengeSpecSolverDns01Route53AuthPtrInput {
	return (*challengeSpecSolverDns01Route53AuthPtrType)(v)
}

func (*challengeSpecSolverDns01Route53AuthPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53Auth)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53AuthPtrType) ToChallengeSpecSolverDns01Route53AuthPtrOutput() ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53AuthPtrType) ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthPtrOutput)
}

// Auth configures how cert-manager authenticates.
type ChallengeSpecSolverDns01Route53AuthOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53Auth)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthOutput) ToChallengeSpecSolverDns01Route53AuthOutput() ChallengeSpecSolverDns01Route53AuthOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthOutput) ToChallengeSpecSolverDns01Route53AuthOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthOutput) ToChallengeSpecSolverDns01Route53AuthPtrOutput() ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53AuthOutput) ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53Auth) *ChallengeSpecSolverDns01Route53Auth {
		return &v
	}).(ChallengeSpecSolverDns01Route53AuthPtrOutput)
}

// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
// by passing a bound ServiceAccount token.
func (o ChallengeSpecSolverDns01Route53AuthOutput) Kubernetes() ChallengeSpecSolverDns01Route53AuthKubernetesOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53Auth) ChallengeSpecSolverDns01Route53AuthKubernetes {
		return v.Kubernetes
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesOutput)
}

type ChallengeSpecSolverDns01Route53AuthPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53Auth)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthPtrOutput) ToChallengeSpecSolverDns01Route53AuthPtrOutput() ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthPtrOutput) ToChallengeSpecSolverDns01Route53AuthPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthPtrOutput) Elem() ChallengeSpecSolverDns01Route53AuthOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53Auth) ChallengeSpecSolverDns01Route53Auth {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53Auth
		return ret
	}).(ChallengeSpecSolverDns01Route53AuthOutput)
}

// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
// by passing a bound ServiceAccount token.
func (o ChallengeSpecSolverDns01Route53AuthPtrOutput) Kubernetes() ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53Auth) *ChallengeSpecSolverDns01Route53AuthKubernetes {
		if v == nil {
			return nil
		}
		return &v.Kubernetes
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput)
}

// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
// by passing a bound ServiceAccount token.
type ChallengeSpecSolverDns01Route53AuthKubernetes struct {
	// A reference to a service account that will be used to request a bound
	// token (also known as "projected token"). To use this field, you must
	// configure an RBAC rule to let cert-manager request a token.
	ServiceAccountRef ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef `pulumi:"serviceAccountRef"`
}

// ChallengeSpecSolverDns01Route53AuthKubernetesInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthKubernetesArgs and ChallengeSpecSolverDns01Route53AuthKubernetesOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthKubernetesInput` via:
//
//	ChallengeSpecSolverDns01Route53AuthKubernetesArgs{...}
type ChallengeSpecSolverDns01Route53AuthKubernetesInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthKubernetesOutput() ChallengeSpecSolverDns01Route53AuthKubernetesOutput
	ToChallengeSpecSolverDns01Route53AuthKubernetesOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesOutput
}

// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
// by passing a bound ServiceAccount token.
type ChallengeSpecSolverDns01Route53AuthKubernetesArgs struct {
	// A reference to a service account that will be used to request a bound
	// token (also known as "projected token"). To use this field, you must
	// configure an RBAC rule to let cert-manager request a token.
	ServiceAccountRef ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefInput `pulumi:"serviceAccountRef"`
}

func (ChallengeSpecSolverDns01Route53AuthKubernetesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetes)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesOutput() ChallengeSpecSolverDns01Route53AuthKubernetesOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesOutput)
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesOutput).ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53AuthKubernetesPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthKubernetesArgs, ChallengeSpecSolverDns01Route53AuthKubernetesPtr and ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthKubernetesPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53AuthKubernetesArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53AuthKubernetesPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput
	ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput
}

type challengeSpecSolverDns01Route53AuthKubernetesPtrType ChallengeSpecSolverDns01Route53AuthKubernetesArgs

func ChallengeSpecSolverDns01Route53AuthKubernetesPtr(v *ChallengeSpecSolverDns01Route53AuthKubernetesArgs) ChallengeSpecSolverDns01Route53AuthKubernetesPtrInput {
	return (*challengeSpecSolverDns01Route53AuthKubernetesPtrType)(v)
}

func (*challengeSpecSolverDns01Route53AuthKubernetesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AuthKubernetes)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53AuthKubernetesPtrType) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53AuthKubernetesPtrType) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput)
}

// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
// by passing a bound ServiceAccount token.
type ChallengeSpecSolverDns01Route53AuthKubernetesOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthKubernetesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetes)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesOutput() ChallengeSpecSolverDns01Route53AuthKubernetesOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53AuthKubernetes) *ChallengeSpecSolverDns01Route53AuthKubernetes {
		return &v
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput)
}

// A reference to a service account that will be used to request a bound
// token (also known as "projected token"). To use this field, you must
// configure an RBAC rule to let cert-manager request a token.
func (o ChallengeSpecSolverDns01Route53AuthKubernetesOutput) ServiceAccountRef() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AuthKubernetes) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef {
		return v.ServiceAccountRef
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput)
}

type ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AuthKubernetes)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput) Elem() ChallengeSpecSolverDns01Route53AuthKubernetesOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthKubernetes) ChallengeSpecSolverDns01Route53AuthKubernetes {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53AuthKubernetes
		return ret
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesOutput)
}

// A reference to a service account that will be used to request a bound
// token (also known as "projected token"). To use this field, you must
// configure an RBAC rule to let cert-manager request a token.
func (o ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput) ServiceAccountRef() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthKubernetes) *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef {
		if v == nil {
			return nil
		}
		return &v.ServiceAccountRef
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput)
}

// A reference to a service account that will be used to request a bound
// token (also known as "projected token"). To use this field, you must
// configure an RBAC rule to let cert-manager request a token.
type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef struct {
	// TokenAudiences is an optional list of audiences to include in the
	// token passed to AWS. The default token consisting of the issuer's namespace
	// and name is always included.
	// If unset the audience defaults to `sts.amazonaws.com`.
	Audiences []string `pulumi:"audiences"`
	// Name of the ServiceAccount used to request a token.
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs and ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefInput` via:
//
//	ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs{...}
type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput
	ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput
}

// A reference to a service account that will be used to request a bound
// token (also known as "projected token"). To use this field, you must
// configure an RBAC rule to let cert-manager request a token.
type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs struct {
	// TokenAudiences is an optional list of audiences to include in the
	// token passed to AWS. The default token consisting of the issuer's namespace
	// and name is always included.
	// If unset the audience defaults to `sts.amazonaws.com`.
	Audiences pulumi.StringArrayInput `pulumi:"audiences"`
	// Name of the ServiceAccount used to request a token.
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput)
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput).ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs, ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtr and ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput
	ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput
}

type challengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrType ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs

func ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtr(v *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrInput {
	return (*challengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrType)(v)
}

func (*challengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrType) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrType) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput)
}

// A reference to a service account that will be used to request a bound
// token (also known as "projected token"). To use this field, you must
// configure an RBAC rule to let cert-manager request a token.
type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef) *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef {
		return &v
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput)
}

// TokenAudiences is an optional list of audiences to include in the
// token passed to AWS. The default token consisting of the issuer's namespace
// and name is always included.
// If unset the audience defaults to `sts.amazonaws.com`.
func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) Audiences() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef) []string { return v.Audiences }).(pulumi.StringArrayOutput)
}

// Name of the ServiceAccount used to request a token.
func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput) ToChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput) Elem() ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef) ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef
		return ret
	}).(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput)
}

// TokenAudiences is an optional list of audiences to include in the
// token passed to AWS. The default token consisting of the issuer's namespace
// and name is always included.
// If unset the audience defaults to `sts.amazonaws.com`.
func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput) Audiences() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef) []string {
		if v == nil {
			return nil
		}
		return v.Audiences
	}).(pulumi.StringArrayOutput)
}

// Name of the ServiceAccount used to request a token.
func (o ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// The SecretAccessKey is used for authentication.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key *string `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name string `pulumi:"name"`
}

// ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefInput is an input type that accepts ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs and ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefInput` via:
//
//	ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs{...}
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput
	ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput
}

// The SecretAccessKey is used for authentication.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs struct {
	// The key of the entry in the Secret resource's `data` field to be used.
	// Some instances of this field may be defaulted, in others it may be
	// required.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Name of the resource being referred to.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringInput `pulumi:"name"`
}

func (ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput {
	return i.ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput)
}

func (i ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput).ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput is an input type that accepts ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs, ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtr and ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput` via:
//
//	        ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput
	ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput
}

type challengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrType ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs

func ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtr(v *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput {
	return (*challengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrType)(v)
}

func (*challengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef)(nil)).Elem()
}

func (i *challengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrType) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return i.ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrType) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput)
}

// The SecretAccessKey is used for authentication.
// If neither the Access Key nor Key ID are set, we fall-back to using env
// vars, shared credentials file or AWS Instance metadata,
// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o.ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef {
		return &v
	}).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) string { return v.Name }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) ToChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) Elem() ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef
		return ret
	}).(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput)
}

// The key of the entry in the Secret resource's `data` field to be used.
// Some instances of this field may be defaulted, in others it may be
// required.
func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) *string {
		if v == nil {
			return nil
		}
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// Name of the resource being referred to.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Route53SecretAccessKeySecretRef) *string {
		if v == nil {
			return nil
		}
		return &v.Name
	}).(pulumi.StringPtrOutput)
}

// Configure an external webhook based DNS01 challenge solver to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01Webhook struct {
	// Additional configuration that should be passed to the webhook apiserver
	// when challenges are processed.
	// This can contain arbitrary JSON data.
	// Secret values should not be specified in this stanza.
	// If secret values are needed (e.g. credentials for a DNS service), you
	// should use a SecretKeySelector to reference a Secret resource.
	// For details on the schema of this field, consult the webhook provider
	// implementation's documentation.
	Config map[string]interface{} `pulumi:"config"`
	// The API group name that should be used when POSTing ChallengePayload
	// resources to the webhook apiserver.
	// This should be the same as the GroupName specified in the webhook
	// provider implementation.
	GroupName string `pulumi:"groupName"`
	// The name of the solver to use, as defined in the webhook provider
	// implementation.
	// This will typically be the name of the provider, e.g. 'cloudflare'.
	SolverName string `pulumi:"solverName"`
}

// ChallengeSpecSolverDns01WebhookInput is an input type that accepts ChallengeSpecSolverDns01WebhookArgs and ChallengeSpecSolverDns01WebhookOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01WebhookInput` via:
//
//	ChallengeSpecSolverDns01WebhookArgs{...}
type ChallengeSpecSolverDns01WebhookInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01WebhookOutput() ChallengeSpecSolverDns01WebhookOutput
	ToChallengeSpecSolverDns01WebhookOutputWithContext(context.Context) ChallengeSpecSolverDns01WebhookOutput
}

// Configure an external webhook based DNS01 challenge solver to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01WebhookArgs struct {
	// Additional configuration that should be passed to the webhook apiserver
	// when challenges are processed.
	// This can contain arbitrary JSON data.
	// Secret values should not be specified in this stanza.
	// If secret values are needed (e.g. credentials for a DNS service), you
	// should use a SecretKeySelector to reference a Secret resource.
	// For details on the schema of this field, consult the webhook provider
	// implementation's documentation.
	Config pulumi.MapInput `pulumi:"config"`
	// The API group name that should be used when POSTing ChallengePayload
	// resources to the webhook apiserver.
	// This should be the same as the GroupName specified in the webhook
	// provider implementation.
	GroupName pulumi.StringInput `pulumi:"groupName"`
	// The name of the solver to use, as defined in the webhook provider
	// implementation.
	// This will typically be the name of the provider, e.g. 'cloudflare'.
	SolverName pulumi.StringInput `pulumi:"solverName"`
}

func (ChallengeSpecSolverDns01WebhookArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Webhook)(nil)).Elem()
}

func (i ChallengeSpecSolverDns01WebhookArgs) ToChallengeSpecSolverDns01WebhookOutput() ChallengeSpecSolverDns01WebhookOutput {
	return i.ToChallengeSpecSolverDns01WebhookOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01WebhookArgs) ToChallengeSpecSolverDns01WebhookOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01WebhookOutput)
}

func (i ChallengeSpecSolverDns01WebhookArgs) ToChallengeSpecSolverDns01WebhookPtrOutput() ChallengeSpecSolverDns01WebhookPtrOutput {
	return i.ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverDns01WebhookArgs) ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01WebhookOutput).ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverDns01WebhookPtrInput is an input type that accepts ChallengeSpecSolverDns01WebhookArgs, ChallengeSpecSolverDns01WebhookPtr and ChallengeSpecSolverDns01WebhookPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverDns01WebhookPtrInput` via:
//
//	        ChallengeSpecSolverDns01WebhookArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverDns01WebhookPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverDns01WebhookPtrOutput() ChallengeSpecSolverDns01WebhookPtrOutput
	ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(context.Context) ChallengeSpecSolverDns01WebhookPtrOutput
}

type challengeSpecSolverDns01WebhookPtrType ChallengeSpecSolverDns01WebhookArgs

func ChallengeSpecSolverDns01WebhookPtr(v *ChallengeSpecSolverDns01WebhookArgs) ChallengeSpecSolverDns01WebhookPtrInput {
	return (*challengeSpecSolverDns01WebhookPtrType)(v)
}

func (*challengeSpecSolverDns01WebhookPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Webhook)(nil)).Elem()
}

func (i *challengeSpecSolverDns01WebhookPtrType) ToChallengeSpecSolverDns01WebhookPtrOutput() ChallengeSpecSolverDns01WebhookPtrOutput {
	return i.ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverDns01WebhookPtrType) ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverDns01WebhookPtrOutput)
}

// Configure an external webhook based DNS01 challenge solver to manage
// DNS01 challenge records.
type ChallengeSpecSolverDns01WebhookOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01WebhookOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverDns01Webhook)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01WebhookOutput) ToChallengeSpecSolverDns01WebhookOutput() ChallengeSpecSolverDns01WebhookOutput {
	return o
}

func (o ChallengeSpecSolverDns01WebhookOutput) ToChallengeSpecSolverDns01WebhookOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookOutput {
	return o
}

func (o ChallengeSpecSolverDns01WebhookOutput) ToChallengeSpecSolverDns01WebhookPtrOutput() ChallengeSpecSolverDns01WebhookPtrOutput {
	return o.ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverDns01WebhookOutput) ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverDns01Webhook) *ChallengeSpecSolverDns01Webhook {
		return &v
	}).(ChallengeSpecSolverDns01WebhookPtrOutput)
}

// Additional configuration that should be passed to the webhook apiserver
// when challenges are processed.
// This can contain arbitrary JSON data.
// Secret values should not be specified in this stanza.
// If secret values are needed (e.g. credentials for a DNS service), you
// should use a SecretKeySelector to reference a Secret resource.
// For details on the schema of this field, consult the webhook provider
// implementation's documentation.
func (o ChallengeSpecSolverDns01WebhookOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Webhook) map[string]interface{} { return v.Config }).(pulumi.MapOutput)
}

// The API group name that should be used when POSTing ChallengePayload
// resources to the webhook apiserver.
// This should be the same as the GroupName specified in the webhook
// provider implementation.
func (o ChallengeSpecSolverDns01WebhookOutput) GroupName() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Webhook) string { return v.GroupName }).(pulumi.StringOutput)
}

// The name of the solver to use, as defined in the webhook provider
// implementation.
// This will typically be the name of the provider, e.g. 'cloudflare'.
func (o ChallengeSpecSolverDns01WebhookOutput) SolverName() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverDns01Webhook) string { return v.SolverName }).(pulumi.StringOutput)
}

type ChallengeSpecSolverDns01WebhookPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverDns01WebhookPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverDns01Webhook)(nil)).Elem()
}

func (o ChallengeSpecSolverDns01WebhookPtrOutput) ToChallengeSpecSolverDns01WebhookPtrOutput() ChallengeSpecSolverDns01WebhookPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01WebhookPtrOutput) ToChallengeSpecSolverDns01WebhookPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverDns01WebhookPtrOutput {
	return o
}

func (o ChallengeSpecSolverDns01WebhookPtrOutput) Elem() ChallengeSpecSolverDns01WebhookOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Webhook) ChallengeSpecSolverDns01Webhook {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverDns01Webhook
		return ret
	}).(ChallengeSpecSolverDns01WebhookOutput)
}

// Additional configuration that should be passed to the webhook apiserver
// when challenges are processed.
// This can contain arbitrary JSON data.
// Secret values should not be specified in this stanza.
// If secret values are needed (e.g. credentials for a DNS service), you
// should use a SecretKeySelector to reference a Secret resource.
// For details on the schema of this field, consult the webhook provider
// implementation's documentation.
func (o ChallengeSpecSolverDns01WebhookPtrOutput) Config() pulumi.MapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Webhook) map[string]interface{} {
		if v == nil {
			return nil
		}
		return v.Config
	}).(pulumi.MapOutput)
}

// The API group name that should be used when POSTing ChallengePayload
// resources to the webhook apiserver.
// This should be the same as the GroupName specified in the webhook
// provider implementation.
func (o ChallengeSpecSolverDns01WebhookPtrOutput) GroupName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Webhook) *string {
		if v == nil {
			return nil
		}
		return &v.GroupName
	}).(pulumi.StringPtrOutput)
}

// The name of the solver to use, as defined in the webhook provider
// implementation.
// This will typically be the name of the provider, e.g. 'cloudflare'.
func (o ChallengeSpecSolverDns01WebhookPtrOutput) SolverName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverDns01Webhook) *string {
		if v == nil {
			return nil
		}
		return &v.SolverName
	}).(pulumi.StringPtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the HTTP01 challenge flow.
// It is not possible to obtain certificates for wildcard domain names
// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
type ChallengeSpecSolverHttp01 struct {
	// The Gateway API is a sig-network community API that models service networking
	// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
	// create HTTPRoutes with the specified labels in the same namespace as the challenge.
	// This solver is experimental, and fields / behaviour may change in the future.
	GatewayHTTPRoute *ChallengeSpecSolverHttp01GatewayHttproute `pulumi:"gatewayHTTPRoute"`
	// The ingress based HTTP01 challenge solver will solve challenges by
	// creating or modifying Ingress resources in order to route requests for
	// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
	// provisioned by cert-manager for each Challenge to be completed.
	Ingress *ChallengeSpecSolverHttp01Ingress `pulumi:"ingress"`
}

// ChallengeSpecSolverHttp01Input is an input type that accepts ChallengeSpecSolverHttp01Args and ChallengeSpecSolverHttp01Output values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01Input` via:
//
//	ChallengeSpecSolverHttp01Args{...}
type ChallengeSpecSolverHttp01Input interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01Output() ChallengeSpecSolverHttp01Output
	ToChallengeSpecSolverHttp01OutputWithContext(context.Context) ChallengeSpecSolverHttp01Output
}

// Configures cert-manager to attempt to complete authorizations by
// performing the HTTP01 challenge flow.
// It is not possible to obtain certificates for wildcard domain names
// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
type ChallengeSpecSolverHttp01Args struct {
	// The Gateway API is a sig-network community API that models service networking
	// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
	// create HTTPRoutes with the specified labels in the same namespace as the challenge.
	// This solver is experimental, and fields / behaviour may change in the future.
	GatewayHTTPRoute ChallengeSpecSolverHttp01GatewayHttproutePtrInput `pulumi:"gatewayHTTPRoute"`
	// The ingress based HTTP01 challenge solver will solve challenges by
	// creating or modifying Ingress resources in order to route requests for
	// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
	// provisioned by cert-manager for each Challenge to be completed.
	Ingress ChallengeSpecSolverHttp01IngressPtrInput `pulumi:"ingress"`
}

func (ChallengeSpecSolverHttp01Args) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01Args) ToChallengeSpecSolverHttp01Output() ChallengeSpecSolverHttp01Output {
	return i.ToChallengeSpecSolverHttp01OutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01Args) ToChallengeSpecSolverHttp01OutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01Output {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01Output)
}

func (i ChallengeSpecSolverHttp01Args) ToChallengeSpecSolverHttp01PtrOutput() ChallengeSpecSolverHttp01PtrOutput {
	return i.ToChallengeSpecSolverHttp01PtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01Args) ToChallengeSpecSolverHttp01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01Output).ToChallengeSpecSolverHttp01PtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01PtrInput is an input type that accepts ChallengeSpecSolverHttp01Args, ChallengeSpecSolverHttp01Ptr and ChallengeSpecSolverHttp01PtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01PtrInput` via:
//
//	        ChallengeSpecSolverHttp01Args{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01PtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01PtrOutput() ChallengeSpecSolverHttp01PtrOutput
	ToChallengeSpecSolverHttp01PtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01PtrOutput
}

type challengeSpecSolverHttp01PtrType ChallengeSpecSolverHttp01Args

func ChallengeSpecSolverHttp01Ptr(v *ChallengeSpecSolverHttp01Args) ChallengeSpecSolverHttp01PtrInput {
	return (*challengeSpecSolverHttp01PtrType)(v)
}

func (*challengeSpecSolverHttp01PtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01PtrType) ToChallengeSpecSolverHttp01PtrOutput() ChallengeSpecSolverHttp01PtrOutput {
	return i.ToChallengeSpecSolverHttp01PtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01PtrType) ToChallengeSpecSolverHttp01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01PtrOutput)
}

// Configures cert-manager to attempt to complete authorizations by
// performing the HTTP01 challenge flow.
// It is not possible to obtain certificates for wildcard domain names
// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
type ChallengeSpecSolverHttp01Output struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01Output) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01Output) ToChallengeSpecSolverHttp01Output() ChallengeSpecSolverHttp01Output {
	return o
}

func (o ChallengeSpecSolverHttp01Output) ToChallengeSpecSolverHttp01OutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01Output {
	return o
}

func (o ChallengeSpecSolverHttp01Output) ToChallengeSpecSolverHttp01PtrOutput() ChallengeSpecSolverHttp01PtrOutput {
	return o.ToChallengeSpecSolverHttp01PtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01Output) ToChallengeSpecSolverHttp01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01) *ChallengeSpecSolverHttp01 {
		return &v
	}).(ChallengeSpecSolverHttp01PtrOutput)
}

// The Gateway API is a sig-network community API that models service networking
// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
// create HTTPRoutes with the specified labels in the same namespace as the challenge.
// This solver is experimental, and fields / behaviour may change in the future.
func (o ChallengeSpecSolverHttp01Output) GatewayHTTPRoute() ChallengeSpecSolverHttp01GatewayHttproutePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01) *ChallengeSpecSolverHttp01GatewayHttproute {
		return v.GatewayHTTPRoute
	}).(ChallengeSpecSolverHttp01GatewayHttproutePtrOutput)
}

// The ingress based HTTP01 challenge solver will solve challenges by
// creating or modifying Ingress resources in order to route requests for
// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
// provisioned by cert-manager for each Challenge to be completed.
func (o ChallengeSpecSolverHttp01Output) Ingress() ChallengeSpecSolverHttp01IngressPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01) *ChallengeSpecSolverHttp01Ingress { return v.Ingress }).(ChallengeSpecSolverHttp01IngressPtrOutput)
}

type ChallengeSpecSolverHttp01PtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01PtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01PtrOutput) ToChallengeSpecSolverHttp01PtrOutput() ChallengeSpecSolverHttp01PtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01PtrOutput) ToChallengeSpecSolverHttp01PtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01PtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01PtrOutput) Elem() ChallengeSpecSolverHttp01Output {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01) ChallengeSpecSolverHttp01 {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01
		return ret
	}).(ChallengeSpecSolverHttp01Output)
}

// The Gateway API is a sig-network community API that models service networking
// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
// create HTTPRoutes with the specified labels in the same namespace as the challenge.
// This solver is experimental, and fields / behaviour may change in the future.
func (o ChallengeSpecSolverHttp01PtrOutput) GatewayHTTPRoute() ChallengeSpecSolverHttp01GatewayHttproutePtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01) *ChallengeSpecSolverHttp01GatewayHttproute {
		if v == nil {
			return nil
		}
		return v.GatewayHTTPRoute
	}).(ChallengeSpecSolverHttp01GatewayHttproutePtrOutput)
}

// The ingress based HTTP01 challenge solver will solve challenges by
// creating or modifying Ingress resources in order to route requests for
// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
// provisioned by cert-manager for each Challenge to be completed.
func (o ChallengeSpecSolverHttp01PtrOutput) Ingress() ChallengeSpecSolverHttp01IngressPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01) *ChallengeSpecSolverHttp01Ingress {
		if v == nil {
			return nil
		}
		return v.Ingress
	}).(ChallengeSpecSolverHttp01IngressPtrOutput)
}

// The Gateway API is a sig-network community API that models service networking
// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
// create HTTPRoutes with the specified labels in the same namespace as the challenge.
// This solver is experimental, and fields / behaviour may change in the future.
type ChallengeSpecSolverHttp01GatewayHttproute struct {
	// Custom labels that will be applied to HTTPRoutes created by cert-manager
	// while solving HTTP-01 challenges.
	Labels map[string]string `pulumi:"labels"`
	// When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute.
	// cert-manager needs to know which parentRefs should be used when creating
	// the HTTPRoute. Usually, the parentRef references a Gateway. See:
	// https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways
	ParentRefs []ChallengeSpecSolverHttp01GatewayHttprouteParentRefs `pulumi:"parentRefs"`
	// Optional pod template used to configure the ACME challenge solver pods
	// used for HTTP01 challenges.
	PodTemplate *ChallengeSpecSolverHttp01GatewayHttproutePodTemplate `pulumi:"podTemplate"`
	// Optional service type for Kubernetes solver service. Supported values
	// are NodePort or ClusterIP. If unset, defaults to NodePort.
	ServiceType *string `pulumi:"serviceType"`
}

// ChallengeSpecSolverHttp01GatewayHttprouteInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttprouteArgs and ChallengeSpecSolverHttp01GatewayHttprouteOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttprouteInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttprouteArgs{...}
type ChallengeSpecSolverHttp01GatewayHttprouteInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttprouteOutput() ChallengeSpecSolverHttp01GatewayHttprouteOutput
	ToChallengeSpecSolverHttp01GatewayHttprouteOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttprouteOutput
}

// The Gateway API is a sig-network community API that models service networking
// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
// create HTTPRoutes with the specified labels in the same namespace as the challenge.
// This solver is experimental, and fields / behaviour may change in the future.
type ChallengeSpecSolverHttp01GatewayHttprouteArgs struct {
	// Custom labels that will be applied to HTTPRoutes created by cert-manager
	// while solving HTTP-01 challenges.
	Labels pulumi.StringMapInput `pulumi:"labels"`
	// When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute.
	// cert-manager needs to know which parentRefs should be used when creating
	// the HTTPRoute. Usually, the parentRef references a Gateway. See:
	// https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways
	ParentRefs ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayInput `pulumi:"parentRefs"`
	// Optional pod template used to configure the ACME challenge solver pods
	// used for HTTP01 challenges.
	PodTemplate ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrInput `pulumi:"podTemplate"`
	// Optional service type for Kubernetes solver service. Supported values
	// are NodePort or ClusterIP. If unset, defaults to NodePort.
	ServiceType pulumi.StringPtrInput `pulumi:"serviceType"`
}

func (ChallengeSpecSolverHttp01GatewayHttprouteArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproute)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttprouteArgs) ToChallengeSpecSolverHttp01GatewayHttprouteOutput() ChallengeSpecSolverHttp01GatewayHttprouteOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttprouteOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttprouteArgs) ToChallengeSpecSolverHttp01GatewayHttprouteOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttprouteOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttprouteOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttprouteArgs) ToChallengeSpecSolverHttp01GatewayHttproutePtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttprouteArgs) ToChallengeSpecSolverHttp01GatewayHttproutePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttprouteOutput).ToChallengeSpecSolverHttp01GatewayHttproutePtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttprouteArgs, ChallengeSpecSolverHttp01GatewayHttproutePtr and ChallengeSpecSolverHttp01GatewayHttproutePtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttprouteArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePtrType ChallengeSpecSolverHttp01GatewayHttprouteArgs

func ChallengeSpecSolverHttp01GatewayHttproutePtr(v *ChallengeSpecSolverHttp01GatewayHttprouteArgs) ChallengeSpecSolverHttp01GatewayHttproutePtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproute)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePtrType) ToChallengeSpecSolverHttp01GatewayHttproutePtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePtrType) ToChallengeSpecSolverHttp01GatewayHttproutePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePtrOutput)
}

// The Gateway API is a sig-network community API that models service networking
// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
// create HTTPRoutes with the specified labels in the same namespace as the challenge.
// This solver is experimental, and fields / behaviour may change in the future.
type ChallengeSpecSolverHttp01GatewayHttprouteOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttprouteOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproute)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttprouteOutput) ToChallengeSpecSolverHttp01GatewayHttprouteOutput() ChallengeSpecSolverHttp01GatewayHttprouteOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttprouteOutput) ToChallengeSpecSolverHttp01GatewayHttprouteOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttprouteOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttprouteOutput) ToChallengeSpecSolverHttp01GatewayHttproutePtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttprouteOutput) ToChallengeSpecSolverHttp01GatewayHttproutePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproute) *ChallengeSpecSolverHttp01GatewayHttproute {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePtrOutput)
}

// Custom labels that will be applied to HTTPRoutes created by cert-manager
// while solving HTTP-01 challenges.
func (o ChallengeSpecSolverHttp01GatewayHttprouteOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproute) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

// When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute.
// cert-manager needs to know which parentRefs should be used when creating
// the HTTPRoute. Usually, the parentRef references a Gateway. See:
// https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways
func (o ChallengeSpecSolverHttp01GatewayHttprouteOutput) ParentRefs() ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproute) []ChallengeSpecSolverHttp01GatewayHttprouteParentRefs {
		return v.ParentRefs
	}).(ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput)
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
func (o ChallengeSpecSolverHttp01GatewayHttprouteOutput) PodTemplate() ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproute) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplate {
		return v.PodTemplate
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput)
}

// Optional service type for Kubernetes solver service. Supported values
// are NodePort or ClusterIP. If unset, defaults to NodePort.
func (o ChallengeSpecSolverHttp01GatewayHttprouteOutput) ServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproute) *string { return v.ServiceType }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproute)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttprouteOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproute) ChallengeSpecSolverHttp01GatewayHttproute {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproute
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttprouteOutput)
}

// Custom labels that will be applied to HTTPRoutes created by cert-manager
// while solving HTTP-01 challenges.
func (o ChallengeSpecSolverHttp01GatewayHttproutePtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproute) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute.
// cert-manager needs to know which parentRefs should be used when creating
// the HTTPRoute. Usually, the parentRef references a Gateway. See:
// https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways
func (o ChallengeSpecSolverHttp01GatewayHttproutePtrOutput) ParentRefs() ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproute) []ChallengeSpecSolverHttp01GatewayHttprouteParentRefs {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput)
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
func (o ChallengeSpecSolverHttp01GatewayHttproutePtrOutput) PodTemplate() ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproute) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplate {
		if v == nil {
			return nil
		}
		return v.PodTemplate
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput)
}

// Optional service type for Kubernetes solver service. Supported values
// are NodePort or ClusterIP. If unset, defaults to NodePort.
func (o ChallengeSpecSolverHttp01GatewayHttproutePtrOutput) ServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproute) *string {
		if v == nil {
			return nil
		}
		return v.ServiceType
	}).(pulumi.StringPtrOutput)
}

// Custom labels that will be applied to HTTPRoutes created by cert-manager
// while solving HTTP-01 challenges.
type ChallengeSpecSolverHttp01GatewayHttprouteLabels struct {
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type ChallengeSpecSolverHttp01GatewayHttprouteParentRefs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// <gateway:experimental:description>
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	// </gateway:experimental:description>
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// <gateway:experimental:description>
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	// </gateway:experimental:description>
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for ChallengeSpecSolverHttp01GatewayHttprouteParentRefs
func (val *ChallengeSpecSolverHttp01GatewayHttprouteParentRefs) Defaults() *ChallengeSpecSolverHttp01GatewayHttprouteParentRefs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		group_ := "gateway.networking.k8s.io"
		tmp.Group = &group_
	}
	if tmp.Kind == nil {
		kind_ := "Gateway"
		tmp.Kind = &kind_
	}
	return &tmp
}

// ChallengeSpecSolverHttp01GatewayHttprouteParentRefsInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs and ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttprouteParentRefsInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs{...}
type ChallengeSpecSolverHttp01GatewayHttprouteParentRefsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput() ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput
	ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// <gateway:experimental:description>
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	// </gateway:experimental:description>
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// <gateway:experimental:description>
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	// </gateway:experimental:description>
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

// Defaults sets the appropriate defaults for ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs
func (val *ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs) Defaults() *ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Group == nil {
		tmp.Group = pulumi.StringPtr("gateway.networking.k8s.io")
	}
	if tmp.Kind == nil {
		tmp.Kind = pulumi.StringPtr("Gateway")
	}
	return &tmp
}
func (ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttprouteParentRefs)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs) ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput() ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs) ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput)
}

// ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArray and ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArray{ ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput() ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArray []ChallengeSpecSolverHttp01GatewayHttprouteParentRefsInput

func (ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttprouteParentRefs)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArray) ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput() ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArray) ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttprouteParentRefs)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput) ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput() ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput) ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput {
	return o
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttprouteParentRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttprouteParentRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttprouteParentRefs) string { return v.Name }).(pulumi.StringOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// <gateway:experimental:description>
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
// </gateway:experimental:description>
//
// Support: Core
func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttprouteParentRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// <gateway:experimental:description>
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
// </gateway:experimental:description>
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttprouteParentRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttprouteParentRefs) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttprouteParentRefs)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput() ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttprouteParentRefs {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttprouteParentRefs)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput)
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplate struct {
	// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
	// Only the 'labels' and 'annotations' fields may be set.
	// If labels or annotations overlap with in-built values, the values here
	// will override the in-built values.
	Metadata *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadata `pulumi:"metadata"`
	// PodSpec defines overrides for the HTTP01 challenge solver pod.
	// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
	// All other fields will be ignored.
	Spec *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec `pulumi:"spec"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateArgs struct {
	// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
	// Only the 'labels' and 'annotations' fields may be set.
	// If labels or annotations overlap with in-built values, the values here
	// will override the in-built values.
	Metadata ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrInput `pulumi:"metadata"`
	// PodSpec defines overrides for the HTTP01 challenge solver pod.
	// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
	// All other fields will be ignored.
	Spec ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrInput `pulumi:"spec"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplate)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput).ToChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateArgs, ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtr and ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttproutePodTemplateArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePodTemplatePtrType ChallengeSpecSolverHttp01GatewayHttproutePodTemplateArgs

func ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtr(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateArgs) ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePodTemplatePtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePodTemplatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplate)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplatePtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplatePtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput)
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplate)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproutePodTemplate) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplate {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput)
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput) Metadata() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplate) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadata {
		return v.Metadata
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput)
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput) Spec() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplate) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec {
		return v.Spec
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplate)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplate) ChallengeSpecSolverHttp01GatewayHttproutePodTemplate {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproutePodTemplate
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput)
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput) Metadata() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplate) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadata {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput)
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput) Spec() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplate) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput)
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadata struct {
	// Annotations that should be added to the created ACME HTTP01 solver pods.
	Annotations map[string]string `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver pods.
	Labels map[string]string `pulumi:"labels"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataArgs struct {
	// Annotations that should be added to the created ACME HTTP01 solver pods.
	Annotations pulumi.StringMapInput `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver pods.
	Labels pulumi.StringMapInput `pulumi:"labels"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadata)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput).ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataArgs, ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtr and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrType ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataArgs

func ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtr(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataArgs) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadata)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput)
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadata)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadata) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadata {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput)
}

// Annotations that should be added to the created ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadata) map[string]string {
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadata) map[string]string {
		return v.Labels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadata)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadata) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadata {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadata
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput)
}

// Annotations that should be added to the created ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// Annotations that should be added to the created ACME HTTP01 solver pods.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataAnnotations struct {
}

// Labels that should be added to the created ACME HTTP01 solver pods.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataLabels struct {
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec struct {
	// If specified, the pod's scheduling constraints
	Affinity *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinity `pulumi:"affinity"`
	// If specified, the pod's imagePullSecrets
	ImagePullSecrets []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecrets `pulumi:"imagePullSecrets"`
	// NodeSelector is a selector which must be true for the pod to fit on a node.
	// Selector which must match a node's labels for the pod to be scheduled on that node.
	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	NodeSelector map[string]string `pulumi:"nodeSelector"`
	// If specified, the pod's priorityClassName.
	PriorityClassName *string `pulumi:"priorityClassName"`
	// If specified, the pod's security context
	SecurityContext *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext `pulumi:"securityContext"`
	// If specified, the pod's service account
	ServiceAccountName *string `pulumi:"serviceAccountName"`
	// If specified, the pod's tolerations.
	Tolerations []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerations `pulumi:"tolerations"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecArgs struct {
	// If specified, the pod's scheduling constraints
	Affinity ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrInput `pulumi:"affinity"`
	// If specified, the pod's imagePullSecrets
	ImagePullSecrets ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayInput `pulumi:"imagePullSecrets"`
	// NodeSelector is a selector which must be true for the pod to fit on a node.
	// Selector which must match a node's labels for the pod to be scheduled on that node.
	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	NodeSelector pulumi.StringMapInput `pulumi:"nodeSelector"`
	// If specified, the pod's priorityClassName.
	PriorityClassName pulumi.StringPtrInput `pulumi:"priorityClassName"`
	// If specified, the pod's security context
	SecurityContext ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrInput `pulumi:"securityContext"`
	// If specified, the pod's service account
	ServiceAccountName pulumi.StringPtrInput `pulumi:"serviceAccountName"`
	// If specified, the pod's tolerations.
	Tolerations ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayInput `pulumi:"tolerations"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput).ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecArgs, ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtr and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrType ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecArgs

func ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtr(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecArgs) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput)
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput)
}

// If specified, the pod's scheduling constraints
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput) Affinity() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinity {
		return v.Affinity
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput)
}

// If specified, the pod's imagePullSecrets
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput) ImagePullSecrets() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecrets {
		return v.ImagePullSecrets
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput)
}

// NodeSelector is a selector which must be true for the pod to fit on a node.
// Selector which must match a node's labels for the pod to be scheduled on that node.
// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput) NodeSelector() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec) map[string]string {
		return v.NodeSelector
	}).(pulumi.StringMapOutput)
}

// If specified, the pod's priorityClassName.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput) PriorityClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec) *string { return v.PriorityClassName }).(pulumi.StringPtrOutput)
}

// If specified, the pod's security context
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput) SecurityContext() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext {
		return v.SecurityContext
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput)
}

// If specified, the pod's service account
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec) *string { return v.ServiceAccountName }).(pulumi.StringPtrOutput)
}

// If specified, the pod's tolerations.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput) Tolerations() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerations {
		return v.Tolerations
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput)
}

// If specified, the pod's scheduling constraints
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput) Affinity() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinity {
		if v == nil {
			return nil
		}
		return v.Affinity
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput)
}

// If specified, the pod's imagePullSecrets
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput) ImagePullSecrets() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecrets {
		if v == nil {
			return nil
		}
		return v.ImagePullSecrets
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput)
}

// NodeSelector is a selector which must be true for the pod to fit on a node.
// Selector which must match a node's labels for the pod to be scheduled on that node.
// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput) NodeSelector() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec) map[string]string {
		if v == nil {
			return nil
		}
		return v.NodeSelector
	}).(pulumi.StringMapOutput)
}

// If specified, the pod's priorityClassName.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput) PriorityClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec) *string {
		if v == nil {
			return nil
		}
		return v.PriorityClassName
	}).(pulumi.StringPtrOutput)
}

// If specified, the pod's security context
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput) SecurityContext() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext {
		if v == nil {
			return nil
		}
		return v.SecurityContext
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput)
}

// If specified, the pod's service account
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec) *string {
		if v == nil {
			return nil
		}
		return v.ServiceAccountName
	}).(pulumi.StringPtrOutput)
}

// If specified, the pod's tolerations.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput) Tolerations() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpec) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerations {
		if v == nil {
			return nil
		}
		return v.Tolerations
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput)
}

// If specified, the pod's scheduling constraints
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinity struct {
	// Describes node affinity scheduling rules for the pod.
	NodeAffinity *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinity `pulumi:"nodeAffinity"`
	// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
	PodAffinity *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinity `pulumi:"podAffinity"`
	// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
	PodAntiAffinity *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinity `pulumi:"podAntiAffinity"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput
}

// If specified, the pod's scheduling constraints
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityArgs struct {
	// Describes node affinity scheduling rules for the pod.
	NodeAffinity ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrInput `pulumi:"nodeAffinity"`
	// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
	PodAffinity ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrInput `pulumi:"podAffinity"`
	// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
	PodAntiAffinity ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrInput `pulumi:"podAntiAffinity"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinity)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput).ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityArgs, ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtr and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrType ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityArgs

func ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtr(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityArgs) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinity)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput)
}

// If specified, the pod's scheduling constraints
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinity) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinity {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput)
}

// Describes node affinity scheduling rules for the pod.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput) NodeAffinity() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinity) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinity {
		return v.NodeAffinity
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput) PodAffinity() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinity) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinity {
		return v.PodAffinity
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput)
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput) PodAntiAffinity() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinity) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinity {
		return v.PodAntiAffinity
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinity) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinity {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinity
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput)
}

// Describes node affinity scheduling rules for the pod.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput) NodeAffinity() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinity) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinity {
		if v == nil {
			return nil
		}
		return v.NodeAffinity
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput) PodAffinity() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinity) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinity {
		if v == nil {
			return nil
		}
		return v.PodAffinity
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput)
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput) PodAntiAffinity() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinity) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinity {
		if v == nil {
			return nil
		}
		return v.PodAntiAffinity
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput)
}

// Describes node affinity scheduling rules for the pod.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinity struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node matches the corresponding matchExpressions; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to an update), the system
	// may or may not try to eventually evict the pod from its node.
	RequiredDuringSchedulingIgnoredDuringExecution *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput
}

// Describes node affinity scheduling rules for the pod.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node matches the corresponding matchExpressions; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to an update), the system
	// may or may not try to eventually evict the pod from its node.
	RequiredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinity)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput).ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityArgs, ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtr and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrType ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityArgs

func ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtr(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityArgs) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinity)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput)
}

// Describes node affinity scheduling rules for the pod.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinity) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinity {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node matches the corresponding matchExpressions; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinity) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinity) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinity) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinity {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinity
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node matches the corresponding matchExpressions; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinity) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinity) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

// An empty preferred scheduling term matches all objects with implicit weight 0
// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution struct {
	// A node selector term, associated with the corresponding weight.
	Preference ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference `pulumi:"preference"`
	// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
	Weight int `pulumi:"weight"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
}

// An empty preferred scheduling term matches all objects with implicit weight 0
// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// A node selector term, associated with the corresponding weight.
	Preference ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput `pulumi:"preference"`
	// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
	Weight pulumi.IntInput `pulumi:"weight"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// An empty preferred scheduling term matches all objects with implicit weight 0
// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// A node selector term, associated with the corresponding weight.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Preference() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
		return v.Preference
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput)
}

// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Weight() pulumi.IntOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution) int {
		return v.Weight
	}).(pulumi.IntOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// A node selector term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields `pulumi:"matchFields"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput
}

// A node selector term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput `pulumi:"matchFields"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput)
}

// A node selector term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return o
}

// A list of node selector requirements by node's labels.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) MatchExpressions() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput)
}

// A list of node selector requirements by node's fields.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) MatchFields() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
		return v.MatchFields
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions struct {
	// The label key that the selector applies to.
	Key string `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields struct {
	// The label key that the selector applies to.
	Key string `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// Required. A list of node selector terms. The terms are ORed.
	NodeSelectorTerms []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms `pulumi:"nodeSelectorTerms"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// Required. A list of node selector terms. The terms are ORed.
	NodeSelectorTerms ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput `pulumi:"nodeSelectorTerms"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput).ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs, ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtr and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs

func ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtr(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

// Required. A list of node selector terms. The terms are ORed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) NodeSelectorTerms() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
		return v.NodeSelectorTerms
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// Required. A list of node selector terms. The terms are ORed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) NodeSelectorTerms() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
		if v == nil {
			return nil
		}
		return v.NodeSelectorTerms
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput)
}

// A null or empty node selector term matches no objects. The requirements of
// them are ANDed.
// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields `pulumi:"matchFields"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput
}

// A null or empty node selector term matches no objects. The requirements of
// them are ANDed.
// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput `pulumi:"matchFields"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput)
}

// A null or empty node selector term matches no objects. The requirements of
// them are ANDed.
// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return o
}

// A list of node selector requirements by node's labels.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) MatchExpressions() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput)
}

// A list of node selector requirements by node's fields.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) MatchFields() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
		return v.MatchFields
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions struct {
	// The label key that the selector applies to.
	Key string `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields struct {
	// The label key that the selector applies to.
	Key string `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinity struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinity)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput).ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityArgs, ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtr and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrType ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityArgs

func ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtr(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityArgs) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinity)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinity) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinity {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinity) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinity) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinity) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinity {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinity
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinity) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinity) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution struct {
	// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	Weight int `pulumi:"weight"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	Weight pulumi.IntInput `pulumi:"weight"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// Required. A pod affinity term, associated with the corresponding weight.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) PodAffinityTerm() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
		return v.PodAffinityTerm
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

// weight associated with matching the corresponding podAffinityTerm,
// in the range 1-100.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Weight() pulumi.IntOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution) int {
		return v.Weight
	}).(pulumi.IntOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MatchLabelKeys []string `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MismatchLabelKeys []string `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MatchLabelKeys pulumi.StringArrayInput `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MismatchLabelKeys pulumi.StringArrayInput `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) LabelSelector() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) NamespaceSelector() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) TopologyKey() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput).ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs, ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs

func ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabels struct {
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput).ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs, ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtr and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs

func ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtr(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchLabels struct {
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MatchLabelKeys []string `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MismatchLabelKeys []string `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MatchLabelKeys pulumi.StringArrayInput `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MismatchLabelKeys pulumi.StringArrayInput `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) LabelSelector() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) NamespaceSelector() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) TopologyKey() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput).ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs, ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs

func ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabels struct {
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput).ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs, ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtr and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs

func ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtr(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchLabels struct {
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinity struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the anti-affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling anti-affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the anti-affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the anti-affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the anti-affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling anti-affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the anti-affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the anti-affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput).ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityArgs, ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtr and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrType ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityArgs

func ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtr(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityArgs) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput)
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinity) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinity {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the anti-affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling anti-affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinity) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the anti-affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the anti-affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinity) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinity) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinity {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinity
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the anti-affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling anti-affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinity) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the anti-affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the anti-affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinity) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution struct {
	// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	Weight int `pulumi:"weight"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	Weight pulumi.IntInput `pulumi:"weight"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// Required. A pod affinity term, associated with the corresponding weight.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) PodAffinityTerm() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
		return v.PodAffinityTerm
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

// weight associated with matching the corresponding podAffinityTerm,
// in the range 1-100.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Weight() pulumi.IntOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution) int {
		return v.Weight
	}).(pulumi.IntOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MatchLabelKeys []string `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MismatchLabelKeys []string `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MatchLabelKeys pulumi.StringArrayInput `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MismatchLabelKeys pulumi.StringArrayInput `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) LabelSelector() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) NamespaceSelector() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) TopologyKey() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput).ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs, ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs

func ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabels struct {
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput).ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs, ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtr and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs

func ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtr(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchLabels struct {
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MatchLabelKeys []string `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MismatchLabelKeys []string `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MatchLabelKeys pulumi.StringArrayInput `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MismatchLabelKeys pulumi.StringArrayInput `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) LabelSelector() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) NamespaceSelector() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) TopologyKey() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput).ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs, ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs

func ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabels struct {
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput).ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs, ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtr and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs

func ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtr(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchLabels struct {
}

// LocalObjectReference contains enough information to let you locate the
// referenced object inside the same namespace.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecrets struct {
	// Name of the referent.
	// This field is effectively required, but due to backwards compatibility is
	// allowed to be empty. Instances of this type with an empty value here are
	// almost certainly wrong.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// Defaults sets the appropriate defaults for ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecrets
func (val *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecrets) Defaults() *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecrets {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Name == nil {
		name_ := ""
		tmp.Name = &name_
	}
	return &tmp
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutput
}

// LocalObjectReference contains enough information to let you locate the
// referenced object inside the same namespace.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArgs struct {
	// Name of the referent.
	// This field is effectively required, but due to backwards compatibility is
	// allowed to be empty. Instances of this type with an empty value here are
	// almost certainly wrong.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

// Defaults sets the appropriate defaults for ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArgs
func (val *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArgs) Defaults() *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Name == nil {
		tmp.Name = pulumi.StringPtr("")
	}
	return &tmp
}
func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecrets)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecrets)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput)
}

// LocalObjectReference contains enough information to let you locate the
// referenced object inside the same namespace.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecrets)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutput {
	return o
}

// Name of the referent.
// This field is effectively required, but due to backwards compatibility is
// allowed to be empty. Instances of this type with an empty value here are
// almost certainly wrong.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecrets) *string {
		return v.Name
	}).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecrets)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecrets {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecrets)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutput)
}

// NodeSelector is a selector which must be true for the pod to fit on a node.
// Selector which must match a node's labels for the pod to be scheduled on that node.
// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecNodeSelector struct {
}

// If specified, the pod's security context
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext struct {
	// A special supplemental group that applies to all containers in a pod.
	// Some volume types allow the Kubelet to change the ownership of that volume
	// to be owned by the pod:
	//
	// 1. The owning GID will be the FSGroup
	// 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
	// 3. The permission bits are OR'd with rw-rw----
	//
	// If unset, the Kubelet will not modify the ownership and permissions of any volume.
	// Note that this field cannot be set when spec.os.name is windows.
	FsGroup *int `pulumi:"fsGroup"`
	// fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
	// before being exposed inside Pod. This field will only apply to
	// volume types which support fsGroup based ownership(and permissions).
	// It will have no effect on ephemeral volume types such as: secret, configmaps
	// and emptydir.
	// Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
	// Note that this field cannot be set when spec.os.name is windows.
	FsGroupChangePolicy *string `pulumi:"fsGroupChangePolicy"`
	// The GID to run the entrypoint of the container process.
	// Uses runtime default if unset.
	// May also be set in SecurityContext.  If set in both SecurityContext and
	// PodSecurityContext, the value specified in SecurityContext takes precedence
	// for that container.
	// Note that this field cannot be set when spec.os.name is windows.
	RunAsGroup *int `pulumi:"runAsGroup"`
	// Indicates that the container must run as a non-root user.
	// If true, the Kubelet will validate the image at runtime to ensure that it
	// does not run as UID 0 (root) and fail to start the container if it does.
	// If unset or false, no such validation will be performed.
	// May also be set in SecurityContext.  If set in both SecurityContext and
	// PodSecurityContext, the value specified in SecurityContext takes precedence.
	RunAsNonRoot *bool `pulumi:"runAsNonRoot"`
	// The UID to run the entrypoint of the container process.
	// Defaults to user specified in image metadata if unspecified.
	// May also be set in SecurityContext.  If set in both SecurityContext and
	// PodSecurityContext, the value specified in SecurityContext takes precedence
	// for that container.
	// Note that this field cannot be set when spec.os.name is windows.
	RunAsUser *int `pulumi:"runAsUser"`
	// The SELinux context to be applied to all containers.
	// If unspecified, the container runtime will allocate a random SELinux context for each
	// container.  May also be set in SecurityContext.  If set in
	// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
	// takes precedence for that container.
	// Note that this field cannot be set when spec.os.name is windows.
	SeLinuxOptions *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions `pulumi:"seLinuxOptions"`
	// The seccomp options to use by the containers in this pod.
	// Note that this field cannot be set when spec.os.name is windows.
	SeccompProfile *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfile `pulumi:"seccompProfile"`
	// A list of groups applied to the first process run in each container, in addition
	// to the container's primary GID, the fsGroup (if specified), and group memberships
	// defined in the container image for the uid of the container process. If unspecified,
	// no additional groups are added to any container. Note that group memberships
	// defined in the container image for the uid of the container process are still effective,
	// even if they are not included in this list.
	// Note that this field cannot be set when spec.os.name is windows.
	SupplementalGroups []int `pulumi:"supplementalGroups"`
	// Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
	// sysctls (by the container runtime) might fail to launch.
	// Note that this field cannot be set when spec.os.name is windows.
	Sysctls []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctls `pulumi:"sysctls"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput
}

// If specified, the pod's security context
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextArgs struct {
	// A special supplemental group that applies to all containers in a pod.
	// Some volume types allow the Kubelet to change the ownership of that volume
	// to be owned by the pod:
	//
	// 1. The owning GID will be the FSGroup
	// 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
	// 3. The permission bits are OR'd with rw-rw----
	//
	// If unset, the Kubelet will not modify the ownership and permissions of any volume.
	// Note that this field cannot be set when spec.os.name is windows.
	FsGroup pulumi.IntPtrInput `pulumi:"fsGroup"`
	// fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
	// before being exposed inside Pod. This field will only apply to
	// volume types which support fsGroup based ownership(and permissions).
	// It will have no effect on ephemeral volume types such as: secret, configmaps
	// and emptydir.
	// Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
	// Note that this field cannot be set when spec.os.name is windows.
	FsGroupChangePolicy pulumi.StringPtrInput `pulumi:"fsGroupChangePolicy"`
	// The GID to run the entrypoint of the container process.
	// Uses runtime default if unset.
	// May also be set in SecurityContext.  If set in both SecurityContext and
	// PodSecurityContext, the value specified in SecurityContext takes precedence
	// for that container.
	// Note that this field cannot be set when spec.os.name is windows.
	RunAsGroup pulumi.IntPtrInput `pulumi:"runAsGroup"`
	// Indicates that the container must run as a non-root user.
	// If true, the Kubelet will validate the image at runtime to ensure that it
	// does not run as UID 0 (root) and fail to start the container if it does.
	// If unset or false, no such validation will be performed.
	// May also be set in SecurityContext.  If set in both SecurityContext and
	// PodSecurityContext, the value specified in SecurityContext takes precedence.
	RunAsNonRoot pulumi.BoolPtrInput `pulumi:"runAsNonRoot"`
	// The UID to run the entrypoint of the container process.
	// Defaults to user specified in image metadata if unspecified.
	// May also be set in SecurityContext.  If set in both SecurityContext and
	// PodSecurityContext, the value specified in SecurityContext takes precedence
	// for that container.
	// Note that this field cannot be set when spec.os.name is windows.
	RunAsUser pulumi.IntPtrInput `pulumi:"runAsUser"`
	// The SELinux context to be applied to all containers.
	// If unspecified, the container runtime will allocate a random SELinux context for each
	// container.  May also be set in SecurityContext.  If set in
	// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
	// takes precedence for that container.
	// Note that this field cannot be set when spec.os.name is windows.
	SeLinuxOptions ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrInput `pulumi:"seLinuxOptions"`
	// The seccomp options to use by the containers in this pod.
	// Note that this field cannot be set when spec.os.name is windows.
	SeccompProfile ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrInput `pulumi:"seccompProfile"`
	// A list of groups applied to the first process run in each container, in addition
	// to the container's primary GID, the fsGroup (if specified), and group memberships
	// defined in the container image for the uid of the container process. If unspecified,
	// no additional groups are added to any container. Note that group memberships
	// defined in the container image for the uid of the container process are still effective,
	// even if they are not included in this list.
	// Note that this field cannot be set when spec.os.name is windows.
	SupplementalGroups pulumi.IntArrayInput `pulumi:"supplementalGroups"`
	// Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
	// sysctls (by the container runtime) might fail to launch.
	// Note that this field cannot be set when spec.os.name is windows.
	Sysctls ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayInput `pulumi:"sysctls"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput).ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextArgs, ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtr and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrType ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextArgs

func ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtr(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextArgs) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput)
}

// If specified, the pod's security context
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput)
}

// A special supplemental group that applies to all containers in a pod.
// Some volume types allow the Kubelet to change the ownership of that volume
// to be owned by the pod:
//
// 1. The owning GID will be the FSGroup
// 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
// 3. The permission bits are OR'd with rw-rw----
//
// If unset, the Kubelet will not modify the ownership and permissions of any volume.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput) FsGroup() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext) *int { return v.FsGroup }).(pulumi.IntPtrOutput)
}

// fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
// before being exposed inside Pod. This field will only apply to
// volume types which support fsGroup based ownership(and permissions).
// It will have no effect on ephemeral volume types such as: secret, configmaps
// and emptydir.
// Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput) FsGroupChangePolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext) *string {
		return v.FsGroupChangePolicy
	}).(pulumi.StringPtrOutput)
}

// The GID to run the entrypoint of the container process.
// Uses runtime default if unset.
// May also be set in SecurityContext.  If set in both SecurityContext and
// PodSecurityContext, the value specified in SecurityContext takes precedence
// for that container.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput) RunAsGroup() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext) *int {
		return v.RunAsGroup
	}).(pulumi.IntPtrOutput)
}

// Indicates that the container must run as a non-root user.
// If true, the Kubelet will validate the image at runtime to ensure that it
// does not run as UID 0 (root) and fail to start the container if it does.
// If unset or false, no such validation will be performed.
// May also be set in SecurityContext.  If set in both SecurityContext and
// PodSecurityContext, the value specified in SecurityContext takes precedence.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput) RunAsNonRoot() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext) *bool {
		return v.RunAsNonRoot
	}).(pulumi.BoolPtrOutput)
}

// The UID to run the entrypoint of the container process.
// Defaults to user specified in image metadata if unspecified.
// May also be set in SecurityContext.  If set in both SecurityContext and
// PodSecurityContext, the value specified in SecurityContext takes precedence
// for that container.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput) RunAsUser() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext) *int {
		return v.RunAsUser
	}).(pulumi.IntPtrOutput)
}

// The SELinux context to be applied to all containers.
// If unspecified, the container runtime will allocate a random SELinux context for each
// container.  May also be set in SecurityContext.  If set in
// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
// takes precedence for that container.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput) SeLinuxOptions() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions {
		return v.SeLinuxOptions
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput)
}

// The seccomp options to use by the containers in this pod.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput) SeccompProfile() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfile {
		return v.SeccompProfile
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput)
}

// A list of groups applied to the first process run in each container, in addition
// to the container's primary GID, the fsGroup (if specified), and group memberships
// defined in the container image for the uid of the container process. If unspecified,
// no additional groups are added to any container. Note that group memberships
// defined in the container image for the uid of the container process are still effective,
// even if they are not included in this list.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput) SupplementalGroups() pulumi.IntArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext) []int {
		return v.SupplementalGroups
	}).(pulumi.IntArrayOutput)
}

// Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
// sysctls (by the container runtime) might fail to launch.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput) Sysctls() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctls {
		return v.Sysctls
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput)
}

// A special supplemental group that applies to all containers in a pod.
// Some volume types allow the Kubelet to change the ownership of that volume
// to be owned by the pod:
//
// 1. The owning GID will be the FSGroup
// 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
// 3. The permission bits are OR'd with rw-rw----
//
// If unset, the Kubelet will not modify the ownership and permissions of any volume.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput) FsGroup() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext) *int {
		if v == nil {
			return nil
		}
		return v.FsGroup
	}).(pulumi.IntPtrOutput)
}

// fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
// before being exposed inside Pod. This field will only apply to
// volume types which support fsGroup based ownership(and permissions).
// It will have no effect on ephemeral volume types such as: secret, configmaps
// and emptydir.
// Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput) FsGroupChangePolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext) *string {
		if v == nil {
			return nil
		}
		return v.FsGroupChangePolicy
	}).(pulumi.StringPtrOutput)
}

// The GID to run the entrypoint of the container process.
// Uses runtime default if unset.
// May also be set in SecurityContext.  If set in both SecurityContext and
// PodSecurityContext, the value specified in SecurityContext takes precedence
// for that container.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput) RunAsGroup() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext) *int {
		if v == nil {
			return nil
		}
		return v.RunAsGroup
	}).(pulumi.IntPtrOutput)
}

// Indicates that the container must run as a non-root user.
// If true, the Kubelet will validate the image at runtime to ensure that it
// does not run as UID 0 (root) and fail to start the container if it does.
// If unset or false, no such validation will be performed.
// May also be set in SecurityContext.  If set in both SecurityContext and
// PodSecurityContext, the value specified in SecurityContext takes precedence.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput) RunAsNonRoot() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext) *bool {
		if v == nil {
			return nil
		}
		return v.RunAsNonRoot
	}).(pulumi.BoolPtrOutput)
}

// The UID to run the entrypoint of the container process.
// Defaults to user specified in image metadata if unspecified.
// May also be set in SecurityContext.  If set in both SecurityContext and
// PodSecurityContext, the value specified in SecurityContext takes precedence
// for that container.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput) RunAsUser() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext) *int {
		if v == nil {
			return nil
		}
		return v.RunAsUser
	}).(pulumi.IntPtrOutput)
}

// The SELinux context to be applied to all containers.
// If unspecified, the container runtime will allocate a random SELinux context for each
// container.  May also be set in SecurityContext.  If set in
// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
// takes precedence for that container.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput) SeLinuxOptions() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions {
		if v == nil {
			return nil
		}
		return v.SeLinuxOptions
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput)
}

// The seccomp options to use by the containers in this pod.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput) SeccompProfile() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfile {
		if v == nil {
			return nil
		}
		return v.SeccompProfile
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput)
}

// A list of groups applied to the first process run in each container, in addition
// to the container's primary GID, the fsGroup (if specified), and group memberships
// defined in the container image for the uid of the container process. If unspecified,
// no additional groups are added to any container. Note that group memberships
// defined in the container image for the uid of the container process are still effective,
// even if they are not included in this list.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput) SupplementalGroups() pulumi.IntArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext) []int {
		if v == nil {
			return nil
		}
		return v.SupplementalGroups
	}).(pulumi.IntArrayOutput)
}

// Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
// sysctls (by the container runtime) might fail to launch.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput) Sysctls() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContext) []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctls {
		if v == nil {
			return nil
		}
		return v.Sysctls
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput)
}

// The SELinux context to be applied to all containers.
// If unspecified, the container runtime will allocate a random SELinux context for each
// container.  May also be set in SecurityContext.  If set in
// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
// takes precedence for that container.
// Note that this field cannot be set when spec.os.name is windows.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions struct {
	// Level is SELinux level label that applies to the container.
	Level *string `pulumi:"level"`
	// Role is a SELinux role label that applies to the container.
	Role *string `pulumi:"role"`
	// Type is a SELinux type label that applies to the container.
	Type *string `pulumi:"type"`
	// User is a SELinux user label that applies to the container.
	User *string `pulumi:"user"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput
}

// The SELinux context to be applied to all containers.
// If unspecified, the container runtime will allocate a random SELinux context for each
// container.  May also be set in SecurityContext.  If set in
// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
// takes precedence for that container.
// Note that this field cannot be set when spec.os.name is windows.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsArgs struct {
	// Level is SELinux level label that applies to the container.
	Level pulumi.StringPtrInput `pulumi:"level"`
	// Role is a SELinux role label that applies to the container.
	Role pulumi.StringPtrInput `pulumi:"role"`
	// Type is a SELinux type label that applies to the container.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// User is a SELinux user label that applies to the container.
	User pulumi.StringPtrInput `pulumi:"user"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput).ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsArgs, ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtr and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrType ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsArgs

func ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtr(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsArgs) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput)
}

// The SELinux context to be applied to all containers.
// If unspecified, the container runtime will allocate a random SELinux context for each
// container.  May also be set in SecurityContext.  If set in
// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
// takes precedence for that container.
// Note that this field cannot be set when spec.os.name is windows.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput)
}

// Level is SELinux level label that applies to the container.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput) Level() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions) *string {
		return v.Level
	}).(pulumi.StringPtrOutput)
}

// Role is a SELinux role label that applies to the container.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions) *string {
		return v.Role
	}).(pulumi.StringPtrOutput)
}

// Type is a SELinux type label that applies to the container.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions) *string {
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// User is a SELinux user label that applies to the container.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput) User() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions) *string {
		return v.User
	}).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput)
}

// Level is SELinux level label that applies to the container.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput) Level() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions) *string {
		if v == nil {
			return nil
		}
		return v.Level
	}).(pulumi.StringPtrOutput)
}

// Role is a SELinux role label that applies to the container.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions) *string {
		if v == nil {
			return nil
		}
		return v.Role
	}).(pulumi.StringPtrOutput)
}

// Type is a SELinux type label that applies to the container.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// User is a SELinux user label that applies to the container.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput) User() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptions) *string {
		if v == nil {
			return nil
		}
		return v.User
	}).(pulumi.StringPtrOutput)
}

// The seccomp options to use by the containers in this pod.
// Note that this field cannot be set when spec.os.name is windows.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfile struct {
	// localhostProfile indicates a profile defined in a file on the node should be used.
	// The profile must be preconfigured on the node to work.
	// Must be a descending path, relative to the kubelet's configured seccomp profile location.
	// Must be set if type is "Localhost". Must NOT be set for any other type.
	LocalhostProfile *string `pulumi:"localhostProfile"`
	// type indicates which kind of seccomp profile will be applied.
	// Valid options are:
	//
	// Localhost - a profile defined in a file on the node should be used.
	// RuntimeDefault - the container runtime default profile should be used.
	// Unconfined - no profile should be applied.
	Type string `pulumi:"type"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput
}

// The seccomp options to use by the containers in this pod.
// Note that this field cannot be set when spec.os.name is windows.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileArgs struct {
	// localhostProfile indicates a profile defined in a file on the node should be used.
	// The profile must be preconfigured on the node to work.
	// Must be a descending path, relative to the kubelet's configured seccomp profile location.
	// Must be set if type is "Localhost". Must NOT be set for any other type.
	LocalhostProfile pulumi.StringPtrInput `pulumi:"localhostProfile"`
	// type indicates which kind of seccomp profile will be applied.
	// Valid options are:
	//
	// Localhost - a profile defined in a file on the node should be used.
	// RuntimeDefault - the container runtime default profile should be used.
	// Unconfined - no profile should be applied.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfile)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput)
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput).ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileArgs, ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtr and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrInput` via:
//
//	        ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput
}

type challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrType ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileArgs

func ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtr(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileArgs) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrInput {
	return (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrType)(v)
}

func (*challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfile)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrType) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput)
}

// The seccomp options to use by the containers in this pod.
// Note that this field cannot be set when spec.os.name is windows.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfile)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput {
	return o.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfile) *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfile {
		return &v
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput)
}

// localhostProfile indicates a profile defined in a file on the node should be used.
// The profile must be preconfigured on the node to work.
// Must be a descending path, relative to the kubelet's configured seccomp profile location.
// Must be set if type is "Localhost". Must NOT be set for any other type.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput) LocalhostProfile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfile) *string {
		return v.LocalhostProfile
	}).(pulumi.StringPtrOutput)
}

// type indicates which kind of seccomp profile will be applied.
// Valid options are:
//
// Localhost - a profile defined in a file on the node should be used.
// RuntimeDefault - the container runtime default profile should be used.
// Unconfined - no profile should be applied.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfile) string {
		return v.Type
	}).(pulumi.StringOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfile)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput) Elem() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfile) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfile {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfile
		return ret
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput)
}

// localhostProfile indicates a profile defined in a file on the node should be used.
// The profile must be preconfigured on the node to work.
// Must be a descending path, relative to the kubelet's configured seccomp profile location.
// Must be set if type is "Localhost". Must NOT be set for any other type.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput) LocalhostProfile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfile) *string {
		if v == nil {
			return nil
		}
		return v.LocalhostProfile
	}).(pulumi.StringPtrOutput)
}

// type indicates which kind of seccomp profile will be applied.
// Valid options are:
//
// Localhost - a profile defined in a file on the node should be used.
// RuntimeDefault - the container runtime default profile should be used.
// Unconfined - no profile should be applied.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfile) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// Sysctl defines a kernel parameter to be set
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctls struct {
	// Name of a property to set
	Name string `pulumi:"name"`
	// Value of a property to set
	Value string `pulumi:"value"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutput
}

// Sysctl defines a kernel parameter to be set
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArgs struct {
	// Name of a property to set
	Name pulumi.StringInput `pulumi:"name"`
	// Value of a property to set
	Value pulumi.StringInput `pulumi:"value"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctls)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctls)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput)
}

// Sysctl defines a kernel parameter to be set
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctls)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutput {
	return o
}

// Name of a property to set
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctls) string {
		return v.Name
	}).(pulumi.StringOutput)
}

// Value of a property to set
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctls) string {
		return v.Value
	}).(pulumi.StringOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctls)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctls {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctls)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutput)
}

// The pod this Toleration is attached to tolerates any taint that matches
// the triple <key,value,effect> using the matching operator <operator>.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerations struct {
	// Effect indicates the taint effect to match. Empty means match all taint effects.
	// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
	Effect *string `pulumi:"effect"`
	// Key is the taint key that the toleration applies to. Empty means match all taint keys.
	// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
	Key *string `pulumi:"key"`
	// Operator represents a key's relationship to the value.
	// Valid operators are Exists and Equal. Defaults to Equal.
	// Exists is equivalent to wildcard for value, so that a pod can
	// tolerate all taints of a particular category.
	Operator *string `pulumi:"operator"`
	// TolerationSeconds represents the period of time the toleration (which must be
	// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
	// it is not set, which means tolerate the taint forever (do not evict). Zero and
	// negative values will be treated as 0 (evict immediately) by the system.
	TolerationSeconds *int `pulumi:"tolerationSeconds"`
	// Value is the taint value the toleration matches to.
	// If the operator is Exists, the value should be empty, otherwise just a regular string.
	Value *string `pulumi:"value"`
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArgs and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArgs{...}
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput
}

// The pod this Toleration is attached to tolerates any taint that matches
// the triple <key,value,effect> using the matching operator <operator>.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArgs struct {
	// Effect indicates the taint effect to match. Empty means match all taint effects.
	// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
	Effect pulumi.StringPtrInput `pulumi:"effect"`
	// Key is the taint key that the toleration applies to. Empty means match all taint keys.
	// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Operator represents a key's relationship to the value.
	// Valid operators are Exists and Equal. Defaults to Equal.
	// Exists is equivalent to wildcard for value, so that a pod can
	// tolerate all taints of a particular category.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// TolerationSeconds represents the period of time the toleration (which must be
	// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
	// it is not set, which means tolerate the taint forever (do not evict). Zero and
	// negative values will be treated as 0 (evict immediately) by the system.
	TolerationSeconds pulumi.IntPtrInput `pulumi:"tolerationSeconds"`
	// Value is the taint value the toleration matches to.
	// If the operator is Exists, the value should be empty, otherwise just a regular string.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerations)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArgs) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput)
}

// ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayInput is an input type that accepts ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArray and ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayInput` via:
//
//	ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArray{ ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArgs{...} }
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput
	ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArray []ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsInput

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerations)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput {
	return i.ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArray) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput)
}

// The pod this Toleration is attached to tolerates any taint that matches
// the triple <key,value,effect> using the matching operator <operator>.
type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerations)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput {
	return o
}

// Effect indicates the taint effect to match. Empty means match all taint effects.
// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput) Effect() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerations) *string { return v.Effect }).(pulumi.StringPtrOutput)
}

// Key is the taint key that the toleration applies to. Empty means match all taint keys.
// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerations) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Operator represents a key's relationship to the value.
// Valid operators are Exists and Equal. Defaults to Equal.
// Exists is equivalent to wildcard for value, so that a pod can
// tolerate all taints of a particular category.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerations) *string { return v.Operator }).(pulumi.StringPtrOutput)
}

// TolerationSeconds represents the period of time the toleration (which must be
// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
// it is not set, which means tolerate the taint forever (do not evict). Zero and
// negative values will be treated as 0 (evict immediately) by the system.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput) TolerationSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerations) *int {
		return v.TolerationSeconds
	}).(pulumi.IntPtrOutput)
}

// Value is the taint value the toleration matches to.
// If the operator is Exists, the value should be empty, otherwise just a regular string.
func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerations) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerations)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput() ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput) ToChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerations {
		return vs[0].([]ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerations)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput)
}

// The ingress based HTTP01 challenge solver will solve challenges by
// creating or modifying Ingress resources in order to route requests for
// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
// provisioned by cert-manager for each Challenge to be completed.
type ChallengeSpecSolverHttp01Ingress struct {
	// This field configures the annotation `kubernetes.io/ingress.class` when
	// creating Ingress resources to solve ACME challenges that use this
	// challenge solver. Only one of `class`, `name` or `ingressClassName` may
	// be specified.
	Class *string `pulumi:"class"`
	// This field configures the field `ingressClassName` on the created Ingress
	// resources used to solve ACME challenges that use this challenge solver.
	// This is the recommended way of configuring the ingress class. Only one of
	// `class`, `name` or `ingressClassName` may be specified.
	IngressClassName *string `pulumi:"ingressClassName"`
	// Optional ingress template used to configure the ACME challenge solver
	// ingress used for HTTP01 challenges.
	IngressTemplate *ChallengeSpecSolverHttp01IngressIngressTemplate `pulumi:"ingressTemplate"`
	// The name of the ingress resource that should have ACME challenge solving
	// routes inserted into it in order to solve HTTP01 challenges.
	// This is typically used in conjunction with ingress controllers like
	// ingress-gce, which maintains a 1:1 mapping between external IPs and
	// ingress resources. Only one of `class`, `name` or `ingressClassName` may
	// be specified.
	Name *string `pulumi:"name"`
	// Optional pod template used to configure the ACME challenge solver pods
	// used for HTTP01 challenges.
	PodTemplate *ChallengeSpecSolverHttp01IngressPodTemplate `pulumi:"podTemplate"`
	// Optional service type for Kubernetes solver service. Supported values
	// are NodePort or ClusterIP. If unset, defaults to NodePort.
	ServiceType *string `pulumi:"serviceType"`
}

// ChallengeSpecSolverHttp01IngressInput is an input type that accepts ChallengeSpecSolverHttp01IngressArgs and ChallengeSpecSolverHttp01IngressOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressInput` via:
//
//	ChallengeSpecSolverHttp01IngressArgs{...}
type ChallengeSpecSolverHttp01IngressInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressOutput() ChallengeSpecSolverHttp01IngressOutput
	ToChallengeSpecSolverHttp01IngressOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressOutput
}

// The ingress based HTTP01 challenge solver will solve challenges by
// creating or modifying Ingress resources in order to route requests for
// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
// provisioned by cert-manager for each Challenge to be completed.
type ChallengeSpecSolverHttp01IngressArgs struct {
	// This field configures the annotation `kubernetes.io/ingress.class` when
	// creating Ingress resources to solve ACME challenges that use this
	// challenge solver. Only one of `class`, `name` or `ingressClassName` may
	// be specified.
	Class pulumi.StringPtrInput `pulumi:"class"`
	// This field configures the field `ingressClassName` on the created Ingress
	// resources used to solve ACME challenges that use this challenge solver.
	// This is the recommended way of configuring the ingress class. Only one of
	// `class`, `name` or `ingressClassName` may be specified.
	IngressClassName pulumi.StringPtrInput `pulumi:"ingressClassName"`
	// Optional ingress template used to configure the ACME challenge solver
	// ingress used for HTTP01 challenges.
	IngressTemplate ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput `pulumi:"ingressTemplate"`
	// The name of the ingress resource that should have ACME challenge solving
	// routes inserted into it in order to solve HTTP01 challenges.
	// This is typically used in conjunction with ingress controllers like
	// ingress-gce, which maintains a 1:1 mapping between external IPs and
	// ingress resources. Only one of `class`, `name` or `ingressClassName` may
	// be specified.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Optional pod template used to configure the ACME challenge solver pods
	// used for HTTP01 challenges.
	PodTemplate ChallengeSpecSolverHttp01IngressPodTemplatePtrInput `pulumi:"podTemplate"`
	// Optional service type for Kubernetes solver service. Supported values
	// are NodePort or ClusterIP. If unset, defaults to NodePort.
	ServiceType pulumi.StringPtrInput `pulumi:"serviceType"`
}

func (ChallengeSpecSolverHttp01IngressArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01Ingress)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressArgs) ToChallengeSpecSolverHttp01IngressOutput() ChallengeSpecSolverHttp01IngressOutput {
	return i.ToChallengeSpecSolverHttp01IngressOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressArgs) ToChallengeSpecSolverHttp01IngressOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressOutput)
}

func (i ChallengeSpecSolverHttp01IngressArgs) ToChallengeSpecSolverHttp01IngressPtrOutput() ChallengeSpecSolverHttp01IngressPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressArgs) ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressOutput).ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressArgs, ChallengeSpecSolverHttp01IngressPtr and ChallengeSpecSolverHttp01IngressPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPtrOutput() ChallengeSpecSolverHttp01IngressPtrOutput
	ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPtrOutput
}

type challengeSpecSolverHttp01IngressPtrType ChallengeSpecSolverHttp01IngressArgs

func ChallengeSpecSolverHttp01IngressPtr(v *ChallengeSpecSolverHttp01IngressArgs) ChallengeSpecSolverHttp01IngressPtrInput {
	return (*challengeSpecSolverHttp01IngressPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01Ingress)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPtrType) ToChallengeSpecSolverHttp01IngressPtrOutput() ChallengeSpecSolverHttp01IngressPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPtrType) ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPtrOutput)
}

// The ingress based HTTP01 challenge solver will solve challenges by
// creating or modifying Ingress resources in order to route requests for
// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
// provisioned by cert-manager for each Challenge to be completed.
type ChallengeSpecSolverHttp01IngressOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01Ingress)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressOutput) ToChallengeSpecSolverHttp01IngressOutput() ChallengeSpecSolverHttp01IngressOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressOutput) ToChallengeSpecSolverHttp01IngressOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressOutput) ToChallengeSpecSolverHttp01IngressPtrOutput() ChallengeSpecSolverHttp01IngressPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressOutput) ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01Ingress) *ChallengeSpecSolverHttp01Ingress {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPtrOutput)
}

// This field configures the annotation `kubernetes.io/ingress.class` when
// creating Ingress resources to solve ACME challenges that use this
// challenge solver. Only one of `class`, `name` or `ingressClassName` may
// be specified.
func (o ChallengeSpecSolverHttp01IngressOutput) Class() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *string { return v.Class }).(pulumi.StringPtrOutput)
}

// This field configures the field `ingressClassName` on the created Ingress
// resources used to solve ACME challenges that use this challenge solver.
// This is the recommended way of configuring the ingress class. Only one of
// `class`, `name` or `ingressClassName` may be specified.
func (o ChallengeSpecSolverHttp01IngressOutput) IngressClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *string { return v.IngressClassName }).(pulumi.StringPtrOutput)
}

// Optional ingress template used to configure the ACME challenge solver
// ingress used for HTTP01 challenges.
func (o ChallengeSpecSolverHttp01IngressOutput) IngressTemplate() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *ChallengeSpecSolverHttp01IngressIngressTemplate {
		return v.IngressTemplate
	}).(ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput)
}

// The name of the ingress resource that should have ACME challenge solving
// routes inserted into it in order to solve HTTP01 challenges.
// This is typically used in conjunction with ingress controllers like
// ingress-gce, which maintains a 1:1 mapping between external IPs and
// ingress resources. Only one of `class`, `name` or `ingressClassName` may
// be specified.
func (o ChallengeSpecSolverHttp01IngressOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
func (o ChallengeSpecSolverHttp01IngressOutput) PodTemplate() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *ChallengeSpecSolverHttp01IngressPodTemplate {
		return v.PodTemplate
	}).(ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput)
}

// Optional service type for Kubernetes solver service. Supported values
// are NodePort or ClusterIP. If unset, defaults to NodePort.
func (o ChallengeSpecSolverHttp01IngressOutput) ServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01Ingress) *string { return v.ServiceType }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01Ingress)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPtrOutput) ToChallengeSpecSolverHttp01IngressPtrOutput() ChallengeSpecSolverHttp01IngressPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPtrOutput) ToChallengeSpecSolverHttp01IngressPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPtrOutput) Elem() ChallengeSpecSolverHttp01IngressOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) ChallengeSpecSolverHttp01Ingress {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01Ingress
		return ret
	}).(ChallengeSpecSolverHttp01IngressOutput)
}

// This field configures the annotation `kubernetes.io/ingress.class` when
// creating Ingress resources to solve ACME challenges that use this
// challenge solver. Only one of `class`, `name` or `ingressClassName` may
// be specified.
func (o ChallengeSpecSolverHttp01IngressPtrOutput) Class() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *string {
		if v == nil {
			return nil
		}
		return v.Class
	}).(pulumi.StringPtrOutput)
}

// This field configures the field `ingressClassName` on the created Ingress
// resources used to solve ACME challenges that use this challenge solver.
// This is the recommended way of configuring the ingress class. Only one of
// `class`, `name` or `ingressClassName` may be specified.
func (o ChallengeSpecSolverHttp01IngressPtrOutput) IngressClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *string {
		if v == nil {
			return nil
		}
		return v.IngressClassName
	}).(pulumi.StringPtrOutput)
}

// Optional ingress template used to configure the ACME challenge solver
// ingress used for HTTP01 challenges.
func (o ChallengeSpecSolverHttp01IngressPtrOutput) IngressTemplate() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *ChallengeSpecSolverHttp01IngressIngressTemplate {
		if v == nil {
			return nil
		}
		return v.IngressTemplate
	}).(ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput)
}

// The name of the ingress resource that should have ACME challenge solving
// routes inserted into it in order to solve HTTP01 challenges.
// This is typically used in conjunction with ingress controllers like
// ingress-gce, which maintains a 1:1 mapping between external IPs and
// ingress resources. Only one of `class`, `name` or `ingressClassName` may
// be specified.
func (o ChallengeSpecSolverHttp01IngressPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
func (o ChallengeSpecSolverHttp01IngressPtrOutput) PodTemplate() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *ChallengeSpecSolverHttp01IngressPodTemplate {
		if v == nil {
			return nil
		}
		return v.PodTemplate
	}).(ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput)
}

// Optional service type for Kubernetes solver service. Supported values
// are NodePort or ClusterIP. If unset, defaults to NodePort.
func (o ChallengeSpecSolverHttp01IngressPtrOutput) ServiceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01Ingress) *string {
		if v == nil {
			return nil
		}
		return v.ServiceType
	}).(pulumi.StringPtrOutput)
}

// Optional ingress template used to configure the ACME challenge solver
// ingress used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressIngressTemplate struct {
	// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
	// Only the 'labels' and 'annotations' fields may be set.
	// If labels or annotations overlap with in-built values, the values here
	// will override the in-built values.
	Metadata *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata `pulumi:"metadata"`
}

// ChallengeSpecSolverHttp01IngressIngressTemplateInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplateArgs and ChallengeSpecSolverHttp01IngressIngressTemplateOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplateInput` via:
//
//	ChallengeSpecSolverHttp01IngressIngressTemplateArgs{...}
type ChallengeSpecSolverHttp01IngressIngressTemplateInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplateOutput() ChallengeSpecSolverHttp01IngressIngressTemplateOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplateOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateOutput
}

// Optional ingress template used to configure the ACME challenge solver
// ingress used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressIngressTemplateArgs struct {
	// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
	// Only the 'labels' and 'annotations' fields may be set.
	// If labels or annotations overlap with in-built values, the values here
	// will override the in-built values.
	Metadata ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput `pulumi:"metadata"`
}

func (ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplate)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateOutput() ChallengeSpecSolverHttp01IngressIngressTemplateOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateOutput)
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateOutput).ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplateArgs, ChallengeSpecSolverHttp01IngressIngressTemplatePtr and ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressIngressTemplateArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput
}

type challengeSpecSolverHttp01IngressIngressTemplatePtrType ChallengeSpecSolverHttp01IngressIngressTemplateArgs

func ChallengeSpecSolverHttp01IngressIngressTemplatePtr(v *ChallengeSpecSolverHttp01IngressIngressTemplateArgs) ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput {
	return (*challengeSpecSolverHttp01IngressIngressTemplatePtrType)(v)
}

func (*challengeSpecSolverHttp01IngressIngressTemplatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressIngressTemplate)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressIngressTemplatePtrType) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressIngressTemplatePtrType) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput)
}

// Optional ingress template used to configure the ACME challenge solver
// ingress used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressIngressTemplateOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplate)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateOutput() ChallengeSpecSolverHttp01IngressIngressTemplateOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressIngressTemplate) *ChallengeSpecSolverHttp01IngressIngressTemplate {
		return &v
	}).(ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput)
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateOutput) Metadata() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressIngressTemplate) *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata {
		return v.Metadata
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput)
}

type ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressIngressTemplate)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput) ToChallengeSpecSolverHttp01IngressIngressTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput) Elem() ChallengeSpecSolverHttp01IngressIngressTemplateOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplate) ChallengeSpecSolverHttp01IngressIngressTemplate {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressIngressTemplate
		return ret
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateOutput)
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
func (o ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput) Metadata() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplate) *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput)
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadata struct {
	// Annotations that should be added to the created ACME HTTP01 solver ingress.
	Annotations map[string]string `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver ingress.
	Labels map[string]string `pulumi:"labels"`
}

// ChallengeSpecSolverHttp01IngressIngressTemplateMetadataInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs and ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplateMetadataInput` via:
//
//	ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs{...}
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs struct {
	// Annotations that should be added to the created ACME HTTP01 solver ingress.
	Annotations pulumi.StringMapInput `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver ingress.
	Labels pulumi.StringMapInput `pulumi:"labels"`
}

func (ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadata)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput)
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput).ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs, ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtr and ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput
	ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput
}

type challengeSpecSolverHttp01IngressIngressTemplateMetadataPtrType ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs

func ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtr(v *ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput {
	return (*challengeSpecSolverHttp01IngressIngressTemplateMetadataPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressIngressTemplateMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressIngressTemplateMetadata)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressIngressTemplateMetadataPtrType) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressIngressTemplateMetadataPtrType) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput)
}

// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadata)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata {
		return &v
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput)
}

// Annotations that should be added to the created ACME HTTP01 solver ingress.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) map[string]string {
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver ingress.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressIngressTemplateMetadata)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) ToChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) Elem() ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) ChallengeSpecSolverHttp01IngressIngressTemplateMetadata {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressIngressTemplateMetadata
		return ret
	}).(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput)
}

// Annotations that should be added to the created ACME HTTP01 solver ingress.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver ingress.
func (o ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressIngressTemplateMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// Annotations that should be added to the created ACME HTTP01 solver ingress.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataAnnotations struct {
}

// Labels that should be added to the created ACME HTTP01 solver ingress.
type ChallengeSpecSolverHttp01IngressIngressTemplateMetadataLabels struct {
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressPodTemplate struct {
	// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
	// Only the 'labels' and 'annotations' fields may be set.
	// If labels or annotations overlap with in-built values, the values here
	// will override the in-built values.
	Metadata *ChallengeSpecSolverHttp01IngressPodTemplateMetadata `pulumi:"metadata"`
	// PodSpec defines overrides for the HTTP01 challenge solver pod.
	// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
	// All other fields will be ignored.
	Spec *ChallengeSpecSolverHttp01IngressPodTemplateSpec `pulumi:"spec"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateArgs and ChallengeSpecSolverHttp01IngressPodTemplateOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateOutput() ChallengeSpecSolverHttp01IngressPodTemplateOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateOutput
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressPodTemplateArgs struct {
	// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
	// Only the 'labels' and 'annotations' fields may be set.
	// If labels or annotations overlap with in-built values, the values here
	// will override the in-built values.
	Metadata ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput `pulumi:"metadata"`
	// PodSpec defines overrides for the HTTP01 challenge solver pod.
	// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
	// All other fields will be ignored.
	Spec ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput `pulumi:"spec"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplate)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateArgs) ToChallengeSpecSolverHttp01IngressPodTemplateOutput() ChallengeSpecSolverHttp01IngressPodTemplateOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateArgs) ToChallengeSpecSolverHttp01IngressPodTemplateOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateArgs) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateArgs) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateOutput).ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplatePtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateArgs, ChallengeSpecSolverHttp01IngressPodTemplatePtr and ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplatePtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplatePtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplatePtrType ChallengeSpecSolverHttp01IngressPodTemplateArgs

func ChallengeSpecSolverHttp01IngressPodTemplatePtr(v *ChallengeSpecSolverHttp01IngressPodTemplateArgs) ChallengeSpecSolverHttp01IngressPodTemplatePtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplatePtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplate)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplatePtrType) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplatePtrType) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput)
}

// Optional pod template used to configure the ACME challenge solver pods
// used for HTTP01 challenges.
type ChallengeSpecSolverHttp01IngressPodTemplateOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplate)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) ToChallengeSpecSolverHttp01IngressPodTemplateOutput() ChallengeSpecSolverHttp01IngressPodTemplateOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) ToChallengeSpecSolverHttp01IngressPodTemplateOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplate) *ChallengeSpecSolverHttp01IngressPodTemplate {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput)
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) Metadata() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplate) *ChallengeSpecSolverHttp01IngressPodTemplateMetadata {
		return v.Metadata
	}).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput)
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
func (o ChallengeSpecSolverHttp01IngressPodTemplateOutput) Spec() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplate) *ChallengeSpecSolverHttp01IngressPodTemplateSpec {
		return v.Spec
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplate)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplatePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplate) ChallengeSpecSolverHttp01IngressPodTemplate {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplate
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateOutput)
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
func (o ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) Metadata() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplate) *ChallengeSpecSolverHttp01IngressPodTemplateMetadata {
		if v == nil {
			return nil
		}
		return v.Metadata
	}).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput)
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
func (o ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput) Spec() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplate) *ChallengeSpecSolverHttp01IngressPodTemplateSpec {
		if v == nil {
			return nil
		}
		return v.Spec
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput)
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadata struct {
	// Annotations that should be added to the created ACME HTTP01 solver pods.
	Annotations map[string]string `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver pods.
	Labels map[string]string `pulumi:"labels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateMetadataInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs and ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateMetadataInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs struct {
	// Annotations that should be added to the created ACME HTTP01 solver pods.
	Annotations pulumi.StringMapInput `pulumi:"annotations"`
	// Labels that should be added to the created ACME HTTP01 solver pods.
	Labels pulumi.StringMapInput `pulumi:"labels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadata)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput).ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs, ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtr and ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateMetadataPtrType ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs

func ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateMetadataPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateMetadataPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateMetadata)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateMetadataPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateMetadataPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput)
}

// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
// Only the 'labels' and 'annotations' fields may be set.
// If labels or annotations overlap with in-built values, the values here
// will override the in-built values.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadata)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateMetadata) *ChallengeSpecSolverHttp01IngressPodTemplateMetadata {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput)
}

// Annotations that should be added to the created ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateMetadata) map[string]string { return v.Annotations }).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateMetadata) map[string]string { return v.Labels }).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateMetadata)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateMetadata) ChallengeSpecSolverHttp01IngressPodTemplateMetadata {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateMetadata
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput)
}

// Annotations that should be added to the created ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) Annotations() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Annotations
	}).(pulumi.StringMapOutput)
}

// Labels that should be added to the created ACME HTTP01 solver pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput) Labels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateMetadata) map[string]string {
		if v == nil {
			return nil
		}
		return v.Labels
	}).(pulumi.StringMapOutput)
}

// Annotations that should be added to the created ACME HTTP01 solver pods.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataAnnotations struct {
}

// Labels that should be added to the created ACME HTTP01 solver pods.
type ChallengeSpecSolverHttp01IngressPodTemplateMetadataLabels struct {
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
type ChallengeSpecSolverHttp01IngressPodTemplateSpec struct {
	// If specified, the pod's scheduling constraints
	Affinity *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity `pulumi:"affinity"`
	// If specified, the pod's imagePullSecrets
	ImagePullSecrets []ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets `pulumi:"imagePullSecrets"`
	// NodeSelector is a selector which must be true for the pod to fit on a node.
	// Selector which must match a node's labels for the pod to be scheduled on that node.
	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	NodeSelector map[string]string `pulumi:"nodeSelector"`
	// If specified, the pod's priorityClassName.
	PriorityClassName *string `pulumi:"priorityClassName"`
	// If specified, the pod's security context
	SecurityContext *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext `pulumi:"securityContext"`
	// If specified, the pod's service account
	ServiceAccountName *string `pulumi:"serviceAccountName"`
	// If specified, the pod's tolerations.
	Tolerations []ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations `pulumi:"tolerations"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs struct {
	// If specified, the pod's scheduling constraints
	Affinity ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput `pulumi:"affinity"`
	// If specified, the pod's imagePullSecrets
	ImagePullSecrets ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayInput `pulumi:"imagePullSecrets"`
	// NodeSelector is a selector which must be true for the pod to fit on a node.
	// Selector which must match a node's labels for the pod to be scheduled on that node.
	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	NodeSelector pulumi.StringMapInput `pulumi:"nodeSelector"`
	// If specified, the pod's priorityClassName.
	PriorityClassName pulumi.StringPtrInput `pulumi:"priorityClassName"`
	// If specified, the pod's security context
	SecurityContext ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrInput `pulumi:"securityContext"`
	// If specified, the pod's service account
	ServiceAccountName pulumi.StringPtrInput `pulumi:"serviceAccountName"`
	// If specified, the pod's tolerations.
	Tolerations ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayInput `pulumi:"tolerations"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpec)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpec)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput)
}

// PodSpec defines overrides for the HTTP01 challenge solver pod.
// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
// All other fields will be ignored.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpec)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpec) *ChallengeSpecSolverHttp01IngressPodTemplateSpec {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput)
}

// If specified, the pod's scheduling constraints
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) Affinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity {
		return v.Affinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput)
}

// If specified, the pod's imagePullSecrets
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ImagePullSecrets() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) []ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets {
		return v.ImagePullSecrets
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput)
}

// NodeSelector is a selector which must be true for the pod to fit on a node.
// Selector which must match a node's labels for the pod to be scheduled on that node.
// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) NodeSelector() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) map[string]string { return v.NodeSelector }).(pulumi.StringMapOutput)
}

// If specified, the pod's priorityClassName.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) PriorityClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) *string { return v.PriorityClassName }).(pulumi.StringPtrOutput)
}

// If specified, the pod's security context
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) SecurityContext() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext {
		return v.SecurityContext
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput)
}

// If specified, the pod's service account
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) *string { return v.ServiceAccountName }).(pulumi.StringPtrOutput)
}

// If specified, the pod's tolerations.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput) Tolerations() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpec) []ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations {
		return v.Tolerations
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpec)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) ChallengeSpecSolverHttp01IngressPodTemplateSpec {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpec
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput)
}

// If specified, the pod's scheduling constraints
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) Affinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity {
		if v == nil {
			return nil
		}
		return v.Affinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput)
}

// If specified, the pod's imagePullSecrets
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) ImagePullSecrets() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) []ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets {
		if v == nil {
			return nil
		}
		return v.ImagePullSecrets
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput)
}

// NodeSelector is a selector which must be true for the pod to fit on a node.
// Selector which must match a node's labels for the pod to be scheduled on that node.
// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) NodeSelector() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) map[string]string {
		if v == nil {
			return nil
		}
		return v.NodeSelector
	}).(pulumi.StringMapOutput)
}

// If specified, the pod's priorityClassName.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) PriorityClassName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) *string {
		if v == nil {
			return nil
		}
		return v.PriorityClassName
	}).(pulumi.StringPtrOutput)
}

// If specified, the pod's security context
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) SecurityContext() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext {
		if v == nil {
			return nil
		}
		return v.SecurityContext
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput)
}

// If specified, the pod's service account
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) ServiceAccountName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) *string {
		if v == nil {
			return nil
		}
		return v.ServiceAccountName
	}).(pulumi.StringPtrOutput)
}

// If specified, the pod's tolerations.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput) Tolerations() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpec) []ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations {
		if v == nil {
			return nil
		}
		return v.Tolerations
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput)
}

// If specified, the pod's scheduling constraints
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity struct {
	// Describes node affinity scheduling rules for the pod.
	NodeAffinity *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity `pulumi:"nodeAffinity"`
	// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
	PodAffinity *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity `pulumi:"podAffinity"`
	// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
	PodAntiAffinity *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity `pulumi:"podAntiAffinity"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput
}

// If specified, the pod's scheduling constraints
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs struct {
	// Describes node affinity scheduling rules for the pod.
	NodeAffinity ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput `pulumi:"nodeAffinity"`
	// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
	PodAffinity ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput `pulumi:"podAffinity"`
	// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
	PodAntiAffinity ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput `pulumi:"podAntiAffinity"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput)
}

// If specified, the pod's scheduling constraints
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput)
}

// Describes node affinity scheduling rules for the pod.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) NodeAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity {
		return v.NodeAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) PodAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity {
		return v.PodAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput)
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput) PodAntiAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity {
		return v.PodAntiAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput)
}

// Describes node affinity scheduling rules for the pod.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) NodeAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity {
		if v == nil {
			return nil
		}
		return v.NodeAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) PodAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity {
		if v == nil {
			return nil
		}
		return v.PodAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput)
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput) PodAntiAffinity() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity {
		if v == nil {
			return nil
		}
		return v.PodAntiAffinity
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput)
}

// Describes node affinity scheduling rules for the pod.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node matches the corresponding matchExpressions; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to an update), the system
	// may or may not try to eventually evict the pod from its node.
	RequiredDuringSchedulingIgnoredDuringExecution *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput
}

// Describes node affinity scheduling rules for the pod.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node matches the corresponding matchExpressions; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to an update), the system
	// may or may not try to eventually evict the pod from its node.
	RequiredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput)
}

// Describes node affinity scheduling rules for the pod.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node matches the corresponding matchExpressions; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node matches the corresponding matchExpressions; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

// An empty preferred scheduling term matches all objects with implicit weight 0
// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution struct {
	// A node selector term, associated with the corresponding weight.
	Preference ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference `pulumi:"preference"`
	// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
	Weight int `pulumi:"weight"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
}

// An empty preferred scheduling term matches all objects with implicit weight 0
// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// A node selector term, associated with the corresponding weight.
	Preference ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput `pulumi:"preference"`
	// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
	Weight pulumi.IntInput `pulumi:"weight"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// An empty preferred scheduling term matches all objects with implicit weight 0
// (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// A node selector term, associated with the corresponding weight.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Preference() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
		return v.Preference
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput)
}

// Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Weight() pulumi.IntOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution) int {
		return v.Weight
	}).(pulumi.IntOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// A node selector term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields `pulumi:"matchFields"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput
}

// A node selector term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput `pulumi:"matchFields"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput)
}

// A node selector term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput {
	return o
}

// A list of node selector requirements by node's labels.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput)
}

// A list of node selector requirements by node's fields.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput) MatchFields() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
		return v.MatchFields
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions struct {
	// The label key that the selector applies to.
	Key string `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields struct {
	// The label key that the selector applies to.
	Key string `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// Required. A list of node selector terms. The terms are ORed.
	NodeSelectorTerms []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms `pulumi:"nodeSelectorTerms"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// Required. A list of node selector terms. The terms are ORed.
	NodeSelectorTerms ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput `pulumi:"nodeSelectorTerms"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to an update), the system
// may or may not try to eventually evict the pod from its node.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput)
}

// Required. A list of node selector terms. The terms are ORed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) NodeSelectorTerms() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
		return v.NodeSelectorTerms
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// Required. A list of node selector terms. The terms are ORed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput) NodeSelectorTerms() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
		if v == nil {
			return nil
		}
		return v.NodeSelectorTerms
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput)
}

// A null or empty node selector term matches no objects. The requirements of
// them are ANDed.
// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields `pulumi:"matchFields"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput
}

// A null or empty node selector term matches no objects. The requirements of
// them are ANDed.
// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs struct {
	// A list of node selector requirements by node's labels.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// A list of node selector requirements by node's fields.
	MatchFields ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput `pulumi:"matchFields"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput)
}

// A null or empty node selector term matches no objects. The requirements of
// them are ANDed.
// The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return o
}

// A list of node selector requirements by node's labels.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput)
}

// A list of node selector requirements by node's fields.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput) MatchFields() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
		return v.MatchFields
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions struct {
	// The label key that the selector applies to.
	Key string `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields struct {
	// The label key that the selector applies to.
	Key string `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator string `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs struct {
	// The label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// Represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator pulumi.StringInput `pulumi:"operator"`
	// An array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	// This array is replaced during a strategic merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput)
}

// A node selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return o
}

// The label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// Represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// An array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. If the operator is Gt or Lt, the values
// array must have a single element, which will be interpreted as an integer.
// This array is replaced during a strategic merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput)
}

// Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution struct {
	// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	Weight int `pulumi:"weight"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	Weight pulumi.IntInput `pulumi:"weight"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// Required. A pod affinity term, associated with the corresponding weight.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) PodAffinityTerm() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
		return v.PodAffinityTerm
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

// weight associated with matching the corresponding podAffinityTerm,
// in the range 1-100.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Weight() pulumi.IntOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution) int {
		return v.Weight
	}).(pulumi.IntOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MatchLabelKeys []string `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MismatchLabelKeys []string `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MatchLabelKeys pulumi.StringArrayInput `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MismatchLabelKeys pulumi.StringArrayInput `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) NamespaceSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) TopologyKey() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabels struct {
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchLabels struct {
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MatchLabelKeys []string `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MismatchLabelKeys []string `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MatchLabelKeys pulumi.StringArrayInput `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MismatchLabelKeys pulumi.StringArrayInput `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) NamespaceSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) TopologyKey() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabels struct {
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchLabels struct {
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the anti-affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling anti-affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the anti-affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the anti-affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs struct {
	// The scheduler will prefer to schedule pods to nodes that satisfy
	// the anti-affinity expressions specified by this field, but it may choose
	// a node that violates one or more of the expressions. The node that is
	// most preferred is the one with the greatest sum of weights, i.e.
	// for each node that meets all of the scheduling requirements (resource
	// request, requiredDuringScheduling anti-affinity expressions, etc.),
	// compute a sum by iterating through the elements of this field and adding
	// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
	// node(s) with the highest sum are the most preferred.
	PreferredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"preferredDuringSchedulingIgnoredDuringExecution"`
	// If the anti-affinity requirements specified by this field are not met at
	// scheduling time, the pod will not be scheduled onto the node.
	// If the anti-affinity requirements specified by this field cease to be met
	// at some point during pod execution (e.g. due to a pod label update), the
	// system may or may not try to eventually evict the pod from its node.
	// When there are multiple elements, the lists of nodes corresponding to each
	// podAffinityTerm are intersected, i.e. all terms must be satisfied.
	RequiredDuringSchedulingIgnoredDuringExecution ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput `pulumi:"requiredDuringSchedulingIgnoredDuringExecution"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput)
}

// Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the anti-affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling anti-affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the anti-affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the anti-affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput)
}

// The scheduler will prefer to schedule pods to nodes that satisfy
// the anti-affinity expressions specified by this field, but it may choose
// a node that violates one or more of the expressions. The node that is
// most preferred is the one with the greatest sum of weights, i.e.
// for each node that meets all of the scheduling requirements (resource
// request, requiredDuringScheduling anti-affinity expressions, etc.),
// compute a sum by iterating through the elements of this field and adding
// "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
// node(s) with the highest sum are the most preferred.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) PreferredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.PreferredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// If the anti-affinity requirements specified by this field are not met at
// scheduling time, the pod will not be scheduled onto the node.
// If the anti-affinity requirements specified by this field cease to be met
// at some point during pod execution (e.g. due to a pod label update), the
// system may or may not try to eventually evict the pod from its node.
// When there are multiple elements, the lists of nodes corresponding to each
// podAffinityTerm are intersected, i.e. all terms must be satisfied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput) RequiredDuringSchedulingIgnoredDuringExecution() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinity) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		if v == nil {
			return nil
		}
		return v.RequiredDuringSchedulingIgnoredDuringExecution
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution struct {
	// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	Weight int `pulumi:"weight"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// Required. A pod affinity term, associated with the corresponding weight.
	PodAffinityTerm ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput `pulumi:"podAffinityTerm"`
	// weight associated with matching the corresponding podAffinityTerm,
	// in the range 1-100.
	Weight pulumi.IntInput `pulumi:"weight"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// Required. A pod affinity term, associated with the corresponding weight.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) PodAffinityTerm() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
		return v.PodAffinityTerm
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

// weight associated with matching the corresponding podAffinityTerm,
// in the range 1-100.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput) Weight() pulumi.IntOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution) int {
		return v.Weight
	}).(pulumi.IntOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MatchLabelKeys []string `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MismatchLabelKeys []string `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MatchLabelKeys pulumi.StringArrayInput `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MismatchLabelKeys pulumi.StringArrayInput `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput)
}

// Required. A pod affinity term, associated with the corresponding weight.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput {
	return o
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) NamespaceSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput) TopologyKey() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchLabels struct {
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchLabels struct {
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MatchLabelKeys []string `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MismatchLabelKeys []string `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces []string `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey string `pulumi:"topologyKey"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs struct {
	// A label query over a set of resources, in this case pods.
	// If it's null, this PodAffinityTerm matches with no Pods.
	LabelSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput `pulumi:"labelSelector"`
	// MatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
	// Also, matchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MatchLabelKeys pulumi.StringArrayInput `pulumi:"matchLabelKeys"`
	// MismatchLabelKeys is a set of pod label keys to select which pods will
	// be taken into consideration. The keys are used to lookup values from the
	// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
	// to select the group of existing pods which pods will be taken into consideration
	// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
	// pod labels will be ignored. The default value is empty.
	// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
	// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
	// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
	MismatchLabelKeys pulumi.StringArrayInput `pulumi:"mismatchLabelKeys"`
	// A label query over the set of namespaces that the term applies to.
	// The term is applied to the union of the namespaces selected by this field
	// and the ones listed in the namespaces field.
	// null selector and null or empty namespaces list means "this pod's namespace".
	// An empty selector ({}) matches all namespaces.
	NamespaceSelector ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput `pulumi:"namespaceSelector"`
	// namespaces specifies a static list of namespace names that the term applies to.
	// The term is applied to the union of the namespaces listed in this field
	// and the ones selected by namespaceSelector.
	// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
	Namespaces pulumi.StringArrayInput `pulumi:"namespaces"`
	// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
	// the labelSelector in the specified namespaces, where co-located is defined as running on a node
	// whose value of the label with key topologyKey matches that of any node on which any of the
	// selected pods is running.
	// Empty topologyKey is not allowed.
	TopologyKey pulumi.StringInput `pulumi:"topologyKey"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput)
}

// Defines a set of pods (namely those matching the labelSelector
// relative to the given namespace(s)) that this pod should be
// co-located (affinity) or not co-located (anti-affinity) with,
// where co-located is defined as running on a node whose value of
// the label with key <topologyKey> matches that of any node on which
// a pod of the set of pods is running
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return o
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) LabelSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return v.LabelSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// MatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both matchLabelKeys and labelSelector.
// Also, matchLabelKeys cannot be set when labelSelector isn't set.
// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) MatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.MatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// MismatchLabelKeys is a set of pod label keys to select which pods will
// be taken into consideration. The keys are used to lookup values from the
// incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
// to select the group of existing pods which pods will be taken into consideration
// for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
// pod labels will be ignored. The default value is empty.
// The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
// Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
// This is a beta field and requires enabling MatchLabelKeysInPodAffinity feature gate (enabled by default).
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) MismatchLabelKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.MismatchLabelKeys
	}).(pulumi.StringArrayOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) NamespaceSelector() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		return v.NamespaceSelector
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// namespaces specifies a static list of namespace names that the term applies to.
// The term is applied to the union of the namespaces listed in this field
// and the ones selected by namespaceSelector.
// null or empty namespaces list and null namespaceSelector means "this pod's namespace".
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) Namespaces() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) []string {
		return v.Namespaces
	}).(pulumi.StringArrayOutput)
}

// This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
// the labelSelector in the specified namespaces, where co-located is defined as running on a node
// whose value of the label with key topologyKey matches that of any node on which any of the
// selected pods is running.
// Empty topologyKey is not allowed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput) TopologyKey() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution) string {
		return v.TopologyKey
	}).(pulumi.StringOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// A label query over a set of resources, in this case pods.
// If it's null, this PodAffinityTerm matches with no Pods.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchLabels struct {
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// A label query over the set of namespaces that the term applies to.
// The term is applied to the union of the namespaces selected by this field
// and the ones listed in the namespaces field.
// null selector and null or empty namespaces list means "this pod's namespace".
// An empty selector ({}) matches all namespaces.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) MatchExpressions() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) string {
		return v.Key
	}).(pulumi.StringOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Operator() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) string {
		return v.Operator
	}).(pulumi.StringOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchLabels struct {
}

// LocalObjectReference contains enough information to let you locate the
// referenced object inside the same namespace.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets struct {
	// Name of the referent.
	// This field is effectively required, but due to backwards compatibility is
	// allowed to be empty. Instances of this type with an empty value here are
	// almost certainly wrong.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name *string `pulumi:"name"`
}

// Defaults sets the appropriate defaults for ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets
func (val *ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets) Defaults() *ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Name == nil {
		name_ := ""
		tmp.Name = &name_
	}
	return &tmp
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput
}

// LocalObjectReference contains enough information to let you locate the
// referenced object inside the same namespace.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs struct {
	// Name of the referent.
	// This field is effectively required, but due to backwards compatibility is
	// allowed to be empty. Instances of this type with an empty value here are
	// almost certainly wrong.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	Name pulumi.StringPtrInput `pulumi:"name"`
}

// Defaults sets the appropriate defaults for ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs
func (val *ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs) Defaults() *ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Name == nil {
		tmp.Name = pulumi.StringPtr("")
	}
	return &tmp
}
func (ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput)
}

// LocalObjectReference contains enough information to let you locate the
// referenced object inside the same namespace.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput {
	return o
}

// Name of the referent.
// This field is effectively required, but due to backwards compatibility is
// allowed to be empty. Instances of this type with an empty value here are
// almost certainly wrong.
// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecrets)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput)
}

// NodeSelector is a selector which must be true for the pod to fit on a node.
// Selector which must match a node's labels for the pod to be scheduled on that node.
// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
type ChallengeSpecSolverHttp01IngressPodTemplateSpecNodeSelector struct {
}

// If specified, the pod's security context
type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext struct {
	// A special supplemental group that applies to all containers in a pod.
	// Some volume types allow the Kubelet to change the ownership of that volume
	// to be owned by the pod:
	//
	// 1. The owning GID will be the FSGroup
	// 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
	// 3. The permission bits are OR'd with rw-rw----
	//
	// If unset, the Kubelet will not modify the ownership and permissions of any volume.
	// Note that this field cannot be set when spec.os.name is windows.
	FsGroup *int `pulumi:"fsGroup"`
	// fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
	// before being exposed inside Pod. This field will only apply to
	// volume types which support fsGroup based ownership(and permissions).
	// It will have no effect on ephemeral volume types such as: secret, configmaps
	// and emptydir.
	// Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
	// Note that this field cannot be set when spec.os.name is windows.
	FsGroupChangePolicy *string `pulumi:"fsGroupChangePolicy"`
	// The GID to run the entrypoint of the container process.
	// Uses runtime default if unset.
	// May also be set in SecurityContext.  If set in both SecurityContext and
	// PodSecurityContext, the value specified in SecurityContext takes precedence
	// for that container.
	// Note that this field cannot be set when spec.os.name is windows.
	RunAsGroup *int `pulumi:"runAsGroup"`
	// Indicates that the container must run as a non-root user.
	// If true, the Kubelet will validate the image at runtime to ensure that it
	// does not run as UID 0 (root) and fail to start the container if it does.
	// If unset or false, no such validation will be performed.
	// May also be set in SecurityContext.  If set in both SecurityContext and
	// PodSecurityContext, the value specified in SecurityContext takes precedence.
	RunAsNonRoot *bool `pulumi:"runAsNonRoot"`
	// The UID to run the entrypoint of the container process.
	// Defaults to user specified in image metadata if unspecified.
	// May also be set in SecurityContext.  If set in both SecurityContext and
	// PodSecurityContext, the value specified in SecurityContext takes precedence
	// for that container.
	// Note that this field cannot be set when spec.os.name is windows.
	RunAsUser *int `pulumi:"runAsUser"`
	// The SELinux context to be applied to all containers.
	// If unspecified, the container runtime will allocate a random SELinux context for each
	// container.  May also be set in SecurityContext.  If set in
	// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
	// takes precedence for that container.
	// Note that this field cannot be set when spec.os.name is windows.
	SeLinuxOptions *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions `pulumi:"seLinuxOptions"`
	// The seccomp options to use by the containers in this pod.
	// Note that this field cannot be set when spec.os.name is windows.
	SeccompProfile *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfile `pulumi:"seccompProfile"`
	// A list of groups applied to the first process run in each container, in addition
	// to the container's primary GID, the fsGroup (if specified), and group memberships
	// defined in the container image for the uid of the container process. If unspecified,
	// no additional groups are added to any container. Note that group memberships
	// defined in the container image for the uid of the container process are still effective,
	// even if they are not included in this list.
	// Note that this field cannot be set when spec.os.name is windows.
	SupplementalGroups []int `pulumi:"supplementalGroups"`
	// Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
	// sysctls (by the container runtime) might fail to launch.
	// Note that this field cannot be set when spec.os.name is windows.
	Sysctls []ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctls `pulumi:"sysctls"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput
}

// If specified, the pod's security context
type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextArgs struct {
	// A special supplemental group that applies to all containers in a pod.
	// Some volume types allow the Kubelet to change the ownership of that volume
	// to be owned by the pod:
	//
	// 1. The owning GID will be the FSGroup
	// 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
	// 3. The permission bits are OR'd with rw-rw----
	//
	// If unset, the Kubelet will not modify the ownership and permissions of any volume.
	// Note that this field cannot be set when spec.os.name is windows.
	FsGroup pulumi.IntPtrInput `pulumi:"fsGroup"`
	// fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
	// before being exposed inside Pod. This field will only apply to
	// volume types which support fsGroup based ownership(and permissions).
	// It will have no effect on ephemeral volume types such as: secret, configmaps
	// and emptydir.
	// Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
	// Note that this field cannot be set when spec.os.name is windows.
	FsGroupChangePolicy pulumi.StringPtrInput `pulumi:"fsGroupChangePolicy"`
	// The GID to run the entrypoint of the container process.
	// Uses runtime default if unset.
	// May also be set in SecurityContext.  If set in both SecurityContext and
	// PodSecurityContext, the value specified in SecurityContext takes precedence
	// for that container.
	// Note that this field cannot be set when spec.os.name is windows.
	RunAsGroup pulumi.IntPtrInput `pulumi:"runAsGroup"`
	// Indicates that the container must run as a non-root user.
	// If true, the Kubelet will validate the image at runtime to ensure that it
	// does not run as UID 0 (root) and fail to start the container if it does.
	// If unset or false, no such validation will be performed.
	// May also be set in SecurityContext.  If set in both SecurityContext and
	// PodSecurityContext, the value specified in SecurityContext takes precedence.
	RunAsNonRoot pulumi.BoolPtrInput `pulumi:"runAsNonRoot"`
	// The UID to run the entrypoint of the container process.
	// Defaults to user specified in image metadata if unspecified.
	// May also be set in SecurityContext.  If set in both SecurityContext and
	// PodSecurityContext, the value specified in SecurityContext takes precedence
	// for that container.
	// Note that this field cannot be set when spec.os.name is windows.
	RunAsUser pulumi.IntPtrInput `pulumi:"runAsUser"`
	// The SELinux context to be applied to all containers.
	// If unspecified, the container runtime will allocate a random SELinux context for each
	// container.  May also be set in SecurityContext.  If set in
	// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
	// takes precedence for that container.
	// Note that this field cannot be set when spec.os.name is windows.
	SeLinuxOptions ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrInput `pulumi:"seLinuxOptions"`
	// The seccomp options to use by the containers in this pod.
	// Note that this field cannot be set when spec.os.name is windows.
	SeccompProfile ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrInput `pulumi:"seccompProfile"`
	// A list of groups applied to the first process run in each container, in addition
	// to the container's primary GID, the fsGroup (if specified), and group memberships
	// defined in the container image for the uid of the container process. If unspecified,
	// no additional groups are added to any container. Note that group memberships
	// defined in the container image for the uid of the container process are still effective,
	// even if they are not included in this list.
	// Note that this field cannot be set when spec.os.name is windows.
	SupplementalGroups pulumi.IntArrayInput `pulumi:"supplementalGroups"`
	// Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
	// sysctls (by the container runtime) might fail to launch.
	// Note that this field cannot be set when spec.os.name is windows.
	Sysctls ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayInput `pulumi:"sysctls"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput)
}

// If specified, the pod's security context
type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext) *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput)
}

// A special supplemental group that applies to all containers in a pod.
// Some volume types allow the Kubelet to change the ownership of that volume
// to be owned by the pod:
//
// 1. The owning GID will be the FSGroup
// 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
// 3. The permission bits are OR'd with rw-rw----
//
// If unset, the Kubelet will not modify the ownership and permissions of any volume.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput) FsGroup() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext) *int { return v.FsGroup }).(pulumi.IntPtrOutput)
}

// fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
// before being exposed inside Pod. This field will only apply to
// volume types which support fsGroup based ownership(and permissions).
// It will have no effect on ephemeral volume types such as: secret, configmaps
// and emptydir.
// Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput) FsGroupChangePolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext) *string {
		return v.FsGroupChangePolicy
	}).(pulumi.StringPtrOutput)
}

// The GID to run the entrypoint of the container process.
// Uses runtime default if unset.
// May also be set in SecurityContext.  If set in both SecurityContext and
// PodSecurityContext, the value specified in SecurityContext takes precedence
// for that container.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput) RunAsGroup() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext) *int { return v.RunAsGroup }).(pulumi.IntPtrOutput)
}

// Indicates that the container must run as a non-root user.
// If true, the Kubelet will validate the image at runtime to ensure that it
// does not run as UID 0 (root) and fail to start the container if it does.
// If unset or false, no such validation will be performed.
// May also be set in SecurityContext.  If set in both SecurityContext and
// PodSecurityContext, the value specified in SecurityContext takes precedence.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput) RunAsNonRoot() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext) *bool { return v.RunAsNonRoot }).(pulumi.BoolPtrOutput)
}

// The UID to run the entrypoint of the container process.
// Defaults to user specified in image metadata if unspecified.
// May also be set in SecurityContext.  If set in both SecurityContext and
// PodSecurityContext, the value specified in SecurityContext takes precedence
// for that container.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput) RunAsUser() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext) *int { return v.RunAsUser }).(pulumi.IntPtrOutput)
}

// The SELinux context to be applied to all containers.
// If unspecified, the container runtime will allocate a random SELinux context for each
// container.  May also be set in SecurityContext.  If set in
// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
// takes precedence for that container.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput) SeLinuxOptions() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext) *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions {
		return v.SeLinuxOptions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput)
}

// The seccomp options to use by the containers in this pod.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput) SeccompProfile() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext) *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfile {
		return v.SeccompProfile
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput)
}

// A list of groups applied to the first process run in each container, in addition
// to the container's primary GID, the fsGroup (if specified), and group memberships
// defined in the container image for the uid of the container process. If unspecified,
// no additional groups are added to any container. Note that group memberships
// defined in the container image for the uid of the container process are still effective,
// even if they are not included in this list.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput) SupplementalGroups() pulumi.IntArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext) []int {
		return v.SupplementalGroups
	}).(pulumi.IntArrayOutput)
}

// Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
// sysctls (by the container runtime) might fail to launch.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput) Sysctls() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext) []ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctls {
		return v.Sysctls
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput)
}

// A special supplemental group that applies to all containers in a pod.
// Some volume types allow the Kubelet to change the ownership of that volume
// to be owned by the pod:
//
// 1. The owning GID will be the FSGroup
// 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
// 3. The permission bits are OR'd with rw-rw----
//
// If unset, the Kubelet will not modify the ownership and permissions of any volume.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput) FsGroup() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext) *int {
		if v == nil {
			return nil
		}
		return v.FsGroup
	}).(pulumi.IntPtrOutput)
}

// fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
// before being exposed inside Pod. This field will only apply to
// volume types which support fsGroup based ownership(and permissions).
// It will have no effect on ephemeral volume types such as: secret, configmaps
// and emptydir.
// Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput) FsGroupChangePolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext) *string {
		if v == nil {
			return nil
		}
		return v.FsGroupChangePolicy
	}).(pulumi.StringPtrOutput)
}

// The GID to run the entrypoint of the container process.
// Uses runtime default if unset.
// May also be set in SecurityContext.  If set in both SecurityContext and
// PodSecurityContext, the value specified in SecurityContext takes precedence
// for that container.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput) RunAsGroup() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext) *int {
		if v == nil {
			return nil
		}
		return v.RunAsGroup
	}).(pulumi.IntPtrOutput)
}

// Indicates that the container must run as a non-root user.
// If true, the Kubelet will validate the image at runtime to ensure that it
// does not run as UID 0 (root) and fail to start the container if it does.
// If unset or false, no such validation will be performed.
// May also be set in SecurityContext.  If set in both SecurityContext and
// PodSecurityContext, the value specified in SecurityContext takes precedence.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput) RunAsNonRoot() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext) *bool {
		if v == nil {
			return nil
		}
		return v.RunAsNonRoot
	}).(pulumi.BoolPtrOutput)
}

// The UID to run the entrypoint of the container process.
// Defaults to user specified in image metadata if unspecified.
// May also be set in SecurityContext.  If set in both SecurityContext and
// PodSecurityContext, the value specified in SecurityContext takes precedence
// for that container.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput) RunAsUser() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext) *int {
		if v == nil {
			return nil
		}
		return v.RunAsUser
	}).(pulumi.IntPtrOutput)
}

// The SELinux context to be applied to all containers.
// If unspecified, the container runtime will allocate a random SELinux context for each
// container.  May also be set in SecurityContext.  If set in
// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
// takes precedence for that container.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput) SeLinuxOptions() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext) *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions {
		if v == nil {
			return nil
		}
		return v.SeLinuxOptions
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput)
}

// The seccomp options to use by the containers in this pod.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput) SeccompProfile() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext) *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfile {
		if v == nil {
			return nil
		}
		return v.SeccompProfile
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput)
}

// A list of groups applied to the first process run in each container, in addition
// to the container's primary GID, the fsGroup (if specified), and group memberships
// defined in the container image for the uid of the container process. If unspecified,
// no additional groups are added to any container. Note that group memberships
// defined in the container image for the uid of the container process are still effective,
// even if they are not included in this list.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput) SupplementalGroups() pulumi.IntArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext) []int {
		if v == nil {
			return nil
		}
		return v.SupplementalGroups
	}).(pulumi.IntArrayOutput)
}

// Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
// sysctls (by the container runtime) might fail to launch.
// Note that this field cannot be set when spec.os.name is windows.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput) Sysctls() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContext) []ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctls {
		if v == nil {
			return nil
		}
		return v.Sysctls
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput)
}

// The SELinux context to be applied to all containers.
// If unspecified, the container runtime will allocate a random SELinux context for each
// container.  May also be set in SecurityContext.  If set in
// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
// takes precedence for that container.
// Note that this field cannot be set when spec.os.name is windows.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions struct {
	// Level is SELinux level label that applies to the container.
	Level *string `pulumi:"level"`
	// Role is a SELinux role label that applies to the container.
	Role *string `pulumi:"role"`
	// Type is a SELinux type label that applies to the container.
	Type *string `pulumi:"type"`
	// User is a SELinux user label that applies to the container.
	User *string `pulumi:"user"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput
}

// The SELinux context to be applied to all containers.
// If unspecified, the container runtime will allocate a random SELinux context for each
// container.  May also be set in SecurityContext.  If set in
// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
// takes precedence for that container.
// Note that this field cannot be set when spec.os.name is windows.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsArgs struct {
	// Level is SELinux level label that applies to the container.
	Level pulumi.StringPtrInput `pulumi:"level"`
	// Role is a SELinux role label that applies to the container.
	Role pulumi.StringPtrInput `pulumi:"role"`
	// Type is a SELinux type label that applies to the container.
	Type pulumi.StringPtrInput `pulumi:"type"`
	// User is a SELinux user label that applies to the container.
	User pulumi.StringPtrInput `pulumi:"user"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput)
}

// The SELinux context to be applied to all containers.
// If unspecified, the container runtime will allocate a random SELinux context for each
// container.  May also be set in SecurityContext.  If set in
// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
// takes precedence for that container.
// Note that this field cannot be set when spec.os.name is windows.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions) *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput)
}

// Level is SELinux level label that applies to the container.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput) Level() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions) *string {
		return v.Level
	}).(pulumi.StringPtrOutput)
}

// Role is a SELinux role label that applies to the container.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions) *string {
		return v.Role
	}).(pulumi.StringPtrOutput)
}

// Type is a SELinux type label that applies to the container.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions) *string {
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// User is a SELinux user label that applies to the container.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput) User() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions) *string {
		return v.User
	}).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput)
}

// Level is SELinux level label that applies to the container.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput) Level() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions) *string {
		if v == nil {
			return nil
		}
		return v.Level
	}).(pulumi.StringPtrOutput)
}

// Role is a SELinux role label that applies to the container.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput) Role() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions) *string {
		if v == nil {
			return nil
		}
		return v.Role
	}).(pulumi.StringPtrOutput)
}

// Type is a SELinux type label that applies to the container.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// User is a SELinux user label that applies to the container.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput) User() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptions) *string {
		if v == nil {
			return nil
		}
		return v.User
	}).(pulumi.StringPtrOutput)
}

// The seccomp options to use by the containers in this pod.
// Note that this field cannot be set when spec.os.name is windows.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfile struct {
	// localhostProfile indicates a profile defined in a file on the node should be used.
	// The profile must be preconfigured on the node to work.
	// Must be a descending path, relative to the kubelet's configured seccomp profile location.
	// Must be set if type is "Localhost". Must NOT be set for any other type.
	LocalhostProfile *string `pulumi:"localhostProfile"`
	// type indicates which kind of seccomp profile will be applied.
	// Valid options are:
	//
	// Localhost - a profile defined in a file on the node should be used.
	// RuntimeDefault - the container runtime default profile should be used.
	// Unconfined - no profile should be applied.
	Type string `pulumi:"type"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput
}

// The seccomp options to use by the containers in this pod.
// Note that this field cannot be set when spec.os.name is windows.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileArgs struct {
	// localhostProfile indicates a profile defined in a file on the node should be used.
	// The profile must be preconfigured on the node to work.
	// Must be a descending path, relative to the kubelet's configured seccomp profile location.
	// Must be set if type is "Localhost". Must NOT be set for any other type.
	LocalhostProfile pulumi.StringPtrInput `pulumi:"localhostProfile"`
	// type indicates which kind of seccomp profile will be applied.
	// Valid options are:
	//
	// Localhost - a profile defined in a file on the node should be used.
	// RuntimeDefault - the container runtime default profile should be used.
	// Unconfined - no profile should be applied.
	Type pulumi.StringInput `pulumi:"type"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfile)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput)
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput).ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutputWithContext(ctx)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileArgs, ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtr and ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrInput` via:
//
//	        ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput
}

type challengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrType ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileArgs

func ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtr(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileArgs) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrInput {
	return (*challengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrType)(v)
}

func (*challengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfile)(nil)).Elem()
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrType) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput)
}

// The seccomp options to use by the containers in this pod.
// Note that this field cannot be set when spec.os.name is windows.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfile)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput {
	return o.ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfile) *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfile {
		return &v
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput)
}

// localhostProfile indicates a profile defined in a file on the node should be used.
// The profile must be preconfigured on the node to work.
// Must be a descending path, relative to the kubelet's configured seccomp profile location.
// Must be set if type is "Localhost". Must NOT be set for any other type.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput) LocalhostProfile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfile) *string {
		return v.LocalhostProfile
	}).(pulumi.StringPtrOutput)
}

// type indicates which kind of seccomp profile will be applied.
// Valid options are:
//
// Localhost - a profile defined in a file on the node should be used.
// RuntimeDefault - the container runtime default profile should be used.
// Unconfined - no profile should be applied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfile) string {
		return v.Type
	}).(pulumi.StringOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfile)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput) Elem() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfile) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfile {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfile
		return ret
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput)
}

// localhostProfile indicates a profile defined in a file on the node should be used.
// The profile must be preconfigured on the node to work.
// Must be a descending path, relative to the kubelet's configured seccomp profile location.
// Must be set if type is "Localhost". Must NOT be set for any other type.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput) LocalhostProfile() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfile) *string {
		if v == nil {
			return nil
		}
		return v.LocalhostProfile
	}).(pulumi.StringPtrOutput)
}

// type indicates which kind of seccomp profile will be applied.
// Valid options are:
//
// Localhost - a profile defined in a file on the node should be used.
// RuntimeDefault - the container runtime default profile should be used.
// Unconfined - no profile should be applied.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfile) *string {
		if v == nil {
			return nil
		}
		return &v.Type
	}).(pulumi.StringPtrOutput)
}

// Sysctl defines a kernel parameter to be set
type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctls struct {
	// Name of a property to set
	Name string `pulumi:"name"`
	// Value of a property to set
	Value string `pulumi:"value"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutput
}

// Sysctl defines a kernel parameter to be set
type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArgs struct {
	// Name of a property to set
	Name pulumi.StringInput `pulumi:"name"`
	// Value of a property to set
	Value pulumi.StringInput `pulumi:"value"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctls)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctls)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput)
}

// Sysctl defines a kernel parameter to be set
type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctls)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutput {
	return o
}

// Name of a property to set
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctls) string { return v.Name }).(pulumi.StringOutput)
}

// Value of a property to set
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutput) Value() pulumi.StringOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctls) string { return v.Value }).(pulumi.StringOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctls)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctls {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctls)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutput)
}

// The pod this Toleration is attached to tolerates any taint that matches
// the triple <key,value,effect> using the matching operator <operator>.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations struct {
	// Effect indicates the taint effect to match. Empty means match all taint effects.
	// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
	Effect *string `pulumi:"effect"`
	// Key is the taint key that the toleration applies to. Empty means match all taint keys.
	// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
	Key *string `pulumi:"key"`
	// Operator represents a key's relationship to the value.
	// Valid operators are Exists and Equal. Defaults to Equal.
	// Exists is equivalent to wildcard for value, so that a pod can
	// tolerate all taints of a particular category.
	Operator *string `pulumi:"operator"`
	// TolerationSeconds represents the period of time the toleration (which must be
	// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
	// it is not set, which means tolerate the taint forever (do not evict). Zero and
	// negative values will be treated as 0 (evict immediately) by the system.
	TolerationSeconds *int `pulumi:"tolerationSeconds"`
	// Value is the taint value the toleration matches to.
	// If the operator is Exists, the value should be empty, otherwise just a regular string.
	Value *string `pulumi:"value"`
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs and ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs{...}
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput
}

// The pod this Toleration is attached to tolerates any taint that matches
// the triple <key,value,effect> using the matching operator <operator>.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs struct {
	// Effect indicates the taint effect to match. Empty means match all taint effects.
	// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
	Effect pulumi.StringPtrInput `pulumi:"effect"`
	// Key is the taint key that the toleration applies to. Empty means match all taint keys.
	// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// Operator represents a key's relationship to the value.
	// Valid operators are Exists and Equal. Defaults to Equal.
	// Exists is equivalent to wildcard for value, so that a pod can
	// tolerate all taints of a particular category.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// TolerationSeconds represents the period of time the toleration (which must be
	// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
	// it is not set, which means tolerate the taint forever (do not evict). Zero and
	// negative values will be treated as 0 (evict immediately) by the system.
	TolerationSeconds pulumi.IntPtrInput `pulumi:"tolerationSeconds"`
	// Value is the taint value the toleration matches to.
	// If the operator is Exists, the value should be empty, otherwise just a regular string.
	Value pulumi.StringPtrInput `pulumi:"value"`
}

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput)
}

// ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayInput is an input type that accepts ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray and ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayInput` via:
//
//	ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray{ ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs{...} }
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayInput interface {
	pulumi.Input

	ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput
	ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutputWithContext(context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray []ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsInput

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations)(nil)).Elem()
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return i.ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput)
}

// The pod this Toleration is attached to tolerates any taint that matches
// the triple <key,value,effect> using the matching operator <operator>.
type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput {
	return o
}

// Effect indicates the taint effect to match. Empty means match all taint effects.
// When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) Effect() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations) *string { return v.Effect }).(pulumi.StringPtrOutput)
}

// Key is the taint key that the toleration applies to. Empty means match all taint keys.
// If the key is empty, operator must be Exists; this combination means to match all values and all keys.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// Operator represents a key's relationship to the value.
// Valid operators are Exists and Equal. Defaults to Equal.
// Exists is equivalent to wildcard for value, so that a pod can
// tolerate all taints of a particular category.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations) *string { return v.Operator }).(pulumi.StringPtrOutput)
}

// TolerationSeconds represents the period of time the toleration (which must be
// of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
// it is not set, which means tolerate the taint forever (do not evict). Zero and
// negative values will be treated as 0 (evict immediately) by the system.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) TolerationSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations) *int { return v.TolerationSeconds }).(pulumi.IntPtrOutput)
}

// Value is the taint value the toleration matches to.
// If the operator is Exists, the value should be empty, otherwise just a regular string.
func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput) Value() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations) *string { return v.Value }).(pulumi.StringPtrOutput)
}

type ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations)(nil)).Elem()
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput() ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput) ToChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutputWithContext(ctx context.Context) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput {
	return o
}

func (o ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput) Index(i pulumi.IntInput) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations {
		return vs[0].([]ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerations)[vs[1].(int)]
	}).(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput)
}

// Selector selects a set of DNSNames on the Certificate resource that
// should be solved using this challenge solver.
// If not specified, the solver will be treated as the 'default' solver
// with the lowest priority, i.e. if any other solver has a more specific
// match, it will be used instead.
type ChallengeSpecSolverSelector struct {
	// List of DNSNames that this solver will be used to solve.
	// If specified and a match is found, a dnsNames selector will take
	// precedence over a dnsZones selector.
	// If multiple solvers match with the same dnsNames value, the solver
	// with the most matching labels in matchLabels will be selected.
	// If neither has more matches, the solver defined earlier in the list
	// will be selected.
	DnsNames []string `pulumi:"dnsNames"`
	// List of DNSZones that this solver will be used to solve.
	// The most specific DNS zone match specified here will take precedence
	// over other DNS zone matches, so a solver specifying sys.example.com
	// will be selected over one specifying example.com for the domain
	// www.sys.example.com.
	// If multiple solvers match with the same dnsZones value, the solver
	// with the most matching labels in matchLabels will be selected.
	// If neither has more matches, the solver defined earlier in the list
	// will be selected.
	DnsZones []string `pulumi:"dnsZones"`
	// A label selector that is used to refine the set of certificate's that
	// this challenge solver will apply to.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// ChallengeSpecSolverSelectorInput is an input type that accepts ChallengeSpecSolverSelectorArgs and ChallengeSpecSolverSelectorOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverSelectorInput` via:
//
//	ChallengeSpecSolverSelectorArgs{...}
type ChallengeSpecSolverSelectorInput interface {
	pulumi.Input

	ToChallengeSpecSolverSelectorOutput() ChallengeSpecSolverSelectorOutput
	ToChallengeSpecSolverSelectorOutputWithContext(context.Context) ChallengeSpecSolverSelectorOutput
}

// Selector selects a set of DNSNames on the Certificate resource that
// should be solved using this challenge solver.
// If not specified, the solver will be treated as the 'default' solver
// with the lowest priority, i.e. if any other solver has a more specific
// match, it will be used instead.
type ChallengeSpecSolverSelectorArgs struct {
	// List of DNSNames that this solver will be used to solve.
	// If specified and a match is found, a dnsNames selector will take
	// precedence over a dnsZones selector.
	// If multiple solvers match with the same dnsNames value, the solver
	// with the most matching labels in matchLabels will be selected.
	// If neither has more matches, the solver defined earlier in the list
	// will be selected.
	DnsNames pulumi.StringArrayInput `pulumi:"dnsNames"`
	// List of DNSZones that this solver will be used to solve.
	// The most specific DNS zone match specified here will take precedence
	// over other DNS zone matches, so a solver specifying sys.example.com
	// will be selected over one specifying example.com for the domain
	// www.sys.example.com.
	// If multiple solvers match with the same dnsZones value, the solver
	// with the most matching labels in matchLabels will be selected.
	// If neither has more matches, the solver defined earlier in the list
	// will be selected.
	DnsZones pulumi.StringArrayInput `pulumi:"dnsZones"`
	// A label selector that is used to refine the set of certificate's that
	// this challenge solver will apply to.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (ChallengeSpecSolverSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverSelector)(nil)).Elem()
}

func (i ChallengeSpecSolverSelectorArgs) ToChallengeSpecSolverSelectorOutput() ChallengeSpecSolverSelectorOutput {
	return i.ToChallengeSpecSolverSelectorOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverSelectorArgs) ToChallengeSpecSolverSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverSelectorOutput)
}

func (i ChallengeSpecSolverSelectorArgs) ToChallengeSpecSolverSelectorPtrOutput() ChallengeSpecSolverSelectorPtrOutput {
	return i.ToChallengeSpecSolverSelectorPtrOutputWithContext(context.Background())
}

func (i ChallengeSpecSolverSelectorArgs) ToChallengeSpecSolverSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverSelectorOutput).ToChallengeSpecSolverSelectorPtrOutputWithContext(ctx)
}

// ChallengeSpecSolverSelectorPtrInput is an input type that accepts ChallengeSpecSolverSelectorArgs, ChallengeSpecSolverSelectorPtr and ChallengeSpecSolverSelectorPtrOutput values.
// You can construct a concrete instance of `ChallengeSpecSolverSelectorPtrInput` via:
//
//	        ChallengeSpecSolverSelectorArgs{...}
//
//	or:
//
//	        nil
type ChallengeSpecSolverSelectorPtrInput interface {
	pulumi.Input

	ToChallengeSpecSolverSelectorPtrOutput() ChallengeSpecSolverSelectorPtrOutput
	ToChallengeSpecSolverSelectorPtrOutputWithContext(context.Context) ChallengeSpecSolverSelectorPtrOutput
}

type challengeSpecSolverSelectorPtrType ChallengeSpecSolverSelectorArgs

func ChallengeSpecSolverSelectorPtr(v *ChallengeSpecSolverSelectorArgs) ChallengeSpecSolverSelectorPtrInput {
	return (*challengeSpecSolverSelectorPtrType)(v)
}

func (*challengeSpecSolverSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverSelector)(nil)).Elem()
}

func (i *challengeSpecSolverSelectorPtrType) ToChallengeSpecSolverSelectorPtrOutput() ChallengeSpecSolverSelectorPtrOutput {
	return i.ToChallengeSpecSolverSelectorPtrOutputWithContext(context.Background())
}

func (i *challengeSpecSolverSelectorPtrType) ToChallengeSpecSolverSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeSpecSolverSelectorPtrOutput)
}

// Selector selects a set of DNSNames on the Certificate resource that
// should be solved using this challenge solver.
// If not specified, the solver will be treated as the 'default' solver
// with the lowest priority, i.e. if any other solver has a more specific
// match, it will be used instead.
type ChallengeSpecSolverSelectorOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeSpecSolverSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverSelectorOutput) ToChallengeSpecSolverSelectorOutput() ChallengeSpecSolverSelectorOutput {
	return o
}

func (o ChallengeSpecSolverSelectorOutput) ToChallengeSpecSolverSelectorOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorOutput {
	return o
}

func (o ChallengeSpecSolverSelectorOutput) ToChallengeSpecSolverSelectorPtrOutput() ChallengeSpecSolverSelectorPtrOutput {
	return o.ToChallengeSpecSolverSelectorPtrOutputWithContext(context.Background())
}

func (o ChallengeSpecSolverSelectorOutput) ToChallengeSpecSolverSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeSpecSolverSelector) *ChallengeSpecSolverSelector {
		return &v
	}).(ChallengeSpecSolverSelectorPtrOutput)
}

// List of DNSNames that this solver will be used to solve.
// If specified and a match is found, a dnsNames selector will take
// precedence over a dnsZones selector.
// If multiple solvers match with the same dnsNames value, the solver
// with the most matching labels in matchLabels will be selected.
// If neither has more matches, the solver defined earlier in the list
// will be selected.
func (o ChallengeSpecSolverSelectorOutput) DnsNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverSelector) []string { return v.DnsNames }).(pulumi.StringArrayOutput)
}

// List of DNSZones that this solver will be used to solve.
// The most specific DNS zone match specified here will take precedence
// over other DNS zone matches, so a solver specifying sys.example.com
// will be selected over one specifying example.com for the domain
// www.sys.example.com.
// If multiple solvers match with the same dnsZones value, the solver
// with the most matching labels in matchLabels will be selected.
// If neither has more matches, the solver defined earlier in the list
// will be selected.
func (o ChallengeSpecSolverSelectorOutput) DnsZones() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ChallengeSpecSolverSelector) []string { return v.DnsZones }).(pulumi.StringArrayOutput)
}

// A label selector that is used to refine the set of certificate's that
// this challenge solver will apply to.
func (o ChallengeSpecSolverSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v ChallengeSpecSolverSelector) map[string]string { return v.MatchLabels }).(pulumi.StringMapOutput)
}

type ChallengeSpecSolverSelectorPtrOutput struct{ *pulumi.OutputState }

func (ChallengeSpecSolverSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeSpecSolverSelector)(nil)).Elem()
}

func (o ChallengeSpecSolverSelectorPtrOutput) ToChallengeSpecSolverSelectorPtrOutput() ChallengeSpecSolverSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverSelectorPtrOutput) ToChallengeSpecSolverSelectorPtrOutputWithContext(ctx context.Context) ChallengeSpecSolverSelectorPtrOutput {
	return o
}

func (o ChallengeSpecSolverSelectorPtrOutput) Elem() ChallengeSpecSolverSelectorOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverSelector) ChallengeSpecSolverSelector {
		if v != nil {
			return *v
		}
		var ret ChallengeSpecSolverSelector
		return ret
	}).(ChallengeSpecSolverSelectorOutput)
}

// List of DNSNames that this solver will be used to solve.
// If specified and a match is found, a dnsNames selector will take
// precedence over a dnsZones selector.
// If multiple solvers match with the same dnsNames value, the solver
// with the most matching labels in matchLabels will be selected.
// If neither has more matches, the solver defined earlier in the list
// will be selected.
func (o ChallengeSpecSolverSelectorPtrOutput) DnsNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverSelector) []string {
		if v == nil {
			return nil
		}
		return v.DnsNames
	}).(pulumi.StringArrayOutput)
}

// List of DNSZones that this solver will be used to solve.
// The most specific DNS zone match specified here will take precedence
// over other DNS zone matches, so a solver specifying sys.example.com
// will be selected over one specifying example.com for the domain
// www.sys.example.com.
// If multiple solvers match with the same dnsZones value, the solver
// with the most matching labels in matchLabels will be selected.
// If neither has more matches, the solver defined earlier in the list
// will be selected.
func (o ChallengeSpecSolverSelectorPtrOutput) DnsZones() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverSelector) []string {
		if v == nil {
			return nil
		}
		return v.DnsZones
	}).(pulumi.StringArrayOutput)
}

// A label selector that is used to refine the set of certificate's that
// this challenge solver will apply to.
func (o ChallengeSpecSolverSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ChallengeSpecSolverSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector that is used to refine the set of certificate's that
// this challenge solver will apply to.
type ChallengeSpecSolverSelectorMatchLabels struct {
}

type ChallengeStatus struct {
	// presented will be set to true if the challenge values for this challenge
	// are currently 'presented'.
	// This *does not* imply the self check is passing. Only that the values
	// have been 'submitted' for the appropriate challenge mechanism (i.e. the
	// DNS01 TXT record has been presented, or the HTTP01 configuration has been
	// configured).
	Presented *bool `pulumi:"presented"`
	// Used to denote whether this challenge should be processed or not.
	// This field will only be set to true by the 'scheduling' component.
	// It will only be set to false by the 'challenges' controller, after the
	// challenge has reached a final state or timed out.
	// If this field is set to false, the challenge controller will not take
	// any more action.
	Processing *bool `pulumi:"processing"`
	// Contains human readable information on why the Challenge is in the
	// current state.
	Reason *string `pulumi:"reason"`
	// Contains the current 'state' of the challenge.
	// If not set, the state of the challenge is unknown.
	State *string `pulumi:"state"`
}

// ChallengeStatusInput is an input type that accepts ChallengeStatusArgs and ChallengeStatusOutput values.
// You can construct a concrete instance of `ChallengeStatusInput` via:
//
//	ChallengeStatusArgs{...}
type ChallengeStatusInput interface {
	pulumi.Input

	ToChallengeStatusOutput() ChallengeStatusOutput
	ToChallengeStatusOutputWithContext(context.Context) ChallengeStatusOutput
}

type ChallengeStatusArgs struct {
	// presented will be set to true if the challenge values for this challenge
	// are currently 'presented'.
	// This *does not* imply the self check is passing. Only that the values
	// have been 'submitted' for the appropriate challenge mechanism (i.e. the
	// DNS01 TXT record has been presented, or the HTTP01 configuration has been
	// configured).
	Presented pulumi.BoolPtrInput `pulumi:"presented"`
	// Used to denote whether this challenge should be processed or not.
	// This field will only be set to true by the 'scheduling' component.
	// It will only be set to false by the 'challenges' controller, after the
	// challenge has reached a final state or timed out.
	// If this field is set to false, the challenge controller will not take
	// any more action.
	Processing pulumi.BoolPtrInput `pulumi:"processing"`
	// Contains human readable information on why the Challenge is in the
	// current state.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// Contains the current 'state' of the challenge.
	// If not set, the state of the challenge is unknown.
	State pulumi.StringPtrInput `pulumi:"state"`
}

func (ChallengeStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeStatus)(nil)).Elem()
}

func (i ChallengeStatusArgs) ToChallengeStatusOutput() ChallengeStatusOutput {
	return i.ToChallengeStatusOutputWithContext(context.Background())
}

func (i ChallengeStatusArgs) ToChallengeStatusOutputWithContext(ctx context.Context) ChallengeStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeStatusOutput)
}

func (i ChallengeStatusArgs) ToChallengeStatusPtrOutput() ChallengeStatusPtrOutput {
	return i.ToChallengeStatusPtrOutputWithContext(context.Background())
}

func (i ChallengeStatusArgs) ToChallengeStatusPtrOutputWithContext(ctx context.Context) ChallengeStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeStatusOutput).ToChallengeStatusPtrOutputWithContext(ctx)
}

// ChallengeStatusPtrInput is an input type that accepts ChallengeStatusArgs, ChallengeStatusPtr and ChallengeStatusPtrOutput values.
// You can construct a concrete instance of `ChallengeStatusPtrInput` via:
//
//	        ChallengeStatusArgs{...}
//
//	or:
//
//	        nil
type ChallengeStatusPtrInput interface {
	pulumi.Input

	ToChallengeStatusPtrOutput() ChallengeStatusPtrOutput
	ToChallengeStatusPtrOutputWithContext(context.Context) ChallengeStatusPtrOutput
}

type challengeStatusPtrType ChallengeStatusArgs

func ChallengeStatusPtr(v *ChallengeStatusArgs) ChallengeStatusPtrInput {
	return (*challengeStatusPtrType)(v)
}

func (*challengeStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeStatus)(nil)).Elem()
}

func (i *challengeStatusPtrType) ToChallengeStatusPtrOutput() ChallengeStatusPtrOutput {
	return i.ToChallengeStatusPtrOutputWithContext(context.Background())
}

func (i *challengeStatusPtrType) ToChallengeStatusPtrOutputWithContext(ctx context.Context) ChallengeStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ChallengeStatusPtrOutput)
}

type ChallengeStatusOutput struct{ *pulumi.OutputState }

func (ChallengeStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ChallengeStatus)(nil)).Elem()
}

func (o ChallengeStatusOutput) ToChallengeStatusOutput() ChallengeStatusOutput {
	return o
}

func (o ChallengeStatusOutput) ToChallengeStatusOutputWithContext(ctx context.Context) ChallengeStatusOutput {
	return o
}

func (o ChallengeStatusOutput) ToChallengeStatusPtrOutput() ChallengeStatusPtrOutput {
	return o.ToChallengeStatusPtrOutputWithContext(context.Background())
}

func (o ChallengeStatusOutput) ToChallengeStatusPtrOutputWithContext(ctx context.Context) ChallengeStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ChallengeStatus) *ChallengeStatus {
		return &v
	}).(ChallengeStatusPtrOutput)
}

// presented will be set to true if the challenge values for this challenge
// are currently 'presented'.
// This *does not* imply the self check is passing. Only that the values
// have been 'submitted' for the appropriate challenge mechanism (i.e. the
// DNS01 TXT record has been presented, or the HTTP01 configuration has been
// configured).
func (o ChallengeStatusOutput) Presented() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ChallengeStatus) *bool { return v.Presented }).(pulumi.BoolPtrOutput)
}

// Used to denote whether this challenge should be processed or not.
// This field will only be set to true by the 'scheduling' component.
// It will only be set to false by the 'challenges' controller, after the
// challenge has reached a final state or timed out.
// If this field is set to false, the challenge controller will not take
// any more action.
func (o ChallengeStatusOutput) Processing() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ChallengeStatus) *bool { return v.Processing }).(pulumi.BoolPtrOutput)
}

// Contains human readable information on why the Challenge is in the
// current state.
func (o ChallengeStatusOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeStatus) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// Contains the current 'state' of the challenge.
// If not set, the state of the challenge is unknown.
func (o ChallengeStatusOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ChallengeStatus) *string { return v.State }).(pulumi.StringPtrOutput)
}

type ChallengeStatusPtrOutput struct{ *pulumi.OutputState }

func (ChallengeStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ChallengeStatus)(nil)).Elem()
}

func (o ChallengeStatusPtrOutput) ToChallengeStatusPtrOutput() ChallengeStatusPtrOutput {
	return o
}

func (o ChallengeStatusPtrOutput) ToChallengeStatusPtrOutputWithContext(ctx context.Context) ChallengeStatusPtrOutput {
	return o
}

func (o ChallengeStatusPtrOutput) Elem() ChallengeStatusOutput {
	return o.ApplyT(func(v *ChallengeStatus) ChallengeStatus {
		if v != nil {
			return *v
		}
		var ret ChallengeStatus
		return ret
	}).(ChallengeStatusOutput)
}

// presented will be set to true if the challenge values for this challenge
// are currently 'presented'.
// This *does not* imply the self check is passing. Only that the values
// have been 'submitted' for the appropriate challenge mechanism (i.e. the
// DNS01 TXT record has been presented, or the HTTP01 configuration has been
// configured).
func (o ChallengeStatusPtrOutput) Presented() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ChallengeStatus) *bool {
		if v == nil {
			return nil
		}
		return v.Presented
	}).(pulumi.BoolPtrOutput)
}

// Used to denote whether this challenge should be processed or not.
// This field will only be set to true by the 'scheduling' component.
// It will only be set to false by the 'challenges' controller, after the
// challenge has reached a final state or timed out.
// If this field is set to false, the challenge controller will not take
// any more action.
func (o ChallengeStatusPtrOutput) Processing() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ChallengeStatus) *bool {
		if v == nil {
			return nil
		}
		return v.Processing
	}).(pulumi.BoolPtrOutput)
}

// Contains human readable information on why the Challenge is in the
// current state.
func (o ChallengeStatusPtrOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeStatus) *string {
		if v == nil {
			return nil
		}
		return v.Reason
	}).(pulumi.StringPtrOutput)
}

// Contains the current 'state' of the challenge.
// If not set, the state of the challenge is unknown.
func (o ChallengeStatusPtrOutput) State() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ChallengeStatus) *string {
		if v == nil {
			return nil
		}
		return v.State
	}).(pulumi.StringPtrOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecInput)(nil)).Elem(), ChallengeSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecPtrInput)(nil)).Elem(), ChallengeSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecIssuerRefInput)(nil)).Elem(), ChallengeSpecIssuerRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecIssuerRefPtrInput)(nil)).Elem(), ChallengeSpecIssuerRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverInput)(nil)).Elem(), ChallengeSpecSolverArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverPtrInput)(nil)).Elem(), ChallengeSpecSolverArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Input)(nil)).Elem(), ChallengeSpecSolverDns01Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01PtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDnsInput)(nil)).Elem(), ChallengeSpecSolverDns01AcmeDnsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDnsPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AcmeDnsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDnsAccountSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AcmeDnsAccountSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientSecretSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiClientSecretSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientTokenSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AkamaiClientTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDnsInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDnsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDnsPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDnsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDnsManagedIdentityInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01AzureDnsManagedIdentityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudDnsInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudDnsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudDnsPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudDnsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflarePtrInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiKeySecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareApiKeySecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiTokenSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01CloudflareApiTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanInput)(nil)).Elem(), ChallengeSpecSolverDns01DigitaloceanArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01DigitaloceanArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanTokenSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01DigitaloceanTokenSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136Input)(nil)).Elem(), ChallengeSpecSolverDns01Rfc2136Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136PtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Rfc2136Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53Input)(nil)).Elem(), ChallengeSpecSolverDns01Route53Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53PtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthKubernetesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthKubernetesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01WebhookInput)(nil)).Elem(), ChallengeSpecSolverDns01WebhookArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverDns01WebhookPtrInput)(nil)).Elem(), ChallengeSpecSolverDns01WebhookArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01Input)(nil)).Elem(), ChallengeSpecSolverHttp01Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01PtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01Args{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttprouteInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttprouteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttprouteArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttprouteParentRefsInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressIngressTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplatePtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressIngressTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadataInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressIngressTemplateMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplatePtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadataInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateMetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayInput)(nil)).Elem(), ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverSelectorInput)(nil)).Elem(), ChallengeSpecSolverSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeSpecSolverSelectorPtrInput)(nil)).Elem(), ChallengeSpecSolverSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeStatusInput)(nil)).Elem(), ChallengeStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ChallengeStatusPtrInput)(nil)).Elem(), ChallengeStatusArgs{})
	pulumi.RegisterOutputType(ChallengeSpecOutput{})
	pulumi.RegisterOutputType(ChallengeSpecPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecIssuerRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecIssuerRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Output{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01PtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AcmeDnsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AcmeDnsPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AcmeDnsAccountSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AcmeDnsAccountSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiAccessTokenSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiClientSecretSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AkamaiClientTokenSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDnsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDnsPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDnsClientSecretSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDnsManagedIdentityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01AzureDnsManagedIdentityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudDnsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudDnsPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudDnsServiceAccountSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflarePtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareApiKeySecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareApiKeySecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01CloudflareApiTokenSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01DigitaloceanOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01DigitaloceanPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01DigitaloceanTokenSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Rfc2136Output{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Rfc2136PtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Rfc2136TsigSecretSecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53Output{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53PtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AccessKeyIdsecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthKubernetesOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthKubernetesPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53AuthKubernetesServiceAccountRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01Route53SecretAccessKeySecretRefPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01WebhookOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverDns01WebhookPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01Output{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01PtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttprouteOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttprouteParentRefsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttprouteParentRefsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplatePtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateMetadataPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecImagePullSecretsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfileOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSeccompProfilePtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecSecurityContextSysctlsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01GatewayHttproutePodTemplateSpecTolerationsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplateOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplatePtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressIngressTemplateMetadataPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplatePtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateMetadataOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateMetadataPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecImagePullSecretsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeLinuxOptionsPtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfileOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSeccompProfilePtrOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecSecurityContextSysctlsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverHttp01IngressPodTemplateSpecTolerationsArrayOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverSelectorOutput{})
	pulumi.RegisterOutputType(ChallengeSpecSolverSelectorPtrOutput{})
	pulumi.RegisterOutputType(ChallengeStatusOutput{})
	pulumi.RegisterOutputType(ChallengeStatusPtrOutput{})
}
